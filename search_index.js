var documenterSearchIndex = {"docs":
[{"location":"processing/#Processing","page":"Processing","title":"Processing","text":"","category":"section"},{"location":"processing/#API","page":"Processing","title":"API","text":"","category":"section"},{"location":"processing/","page":"Processing","title":"Processing","text":"Modules = [Processing]","category":"page"},{"location":"processing/#Processing.cleanup_ohlcv_data-Tuple{Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.cleanup_ohlcv_data","text":"Similar to the freqtrade homonymous function.\n\nfill_missing: :close fills non present candles with previous close and 0 volume, else with NaN.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.fill_missing_candles-Tuple{Any, AbstractString}","page":"Processing","title":"Processing.fill_missing_candles","text":"Assuming timestamps are sorted, returns a new dataframe with a contiguous rows based on timeframe. Rows are filled either by previous close, or NaN. \n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.iscomplete-Tuple{Any, Any}","page":"Processing","title":"Processing.iscomplete","text":"Checks if a candle is old enough to be complete.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.isincomplete-Tuple{Data.Candle, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isincomplete","text":"Checks if a candle is too new.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.islast-Tuple{Dates.DateTime, Any, Val{:raw}}","page":"Processing","title":"Processing.islast","text":"Checks if a candle is exactly the latest candle.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.isleftadj-Tuple{Any, Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isleftadj","text":"a is left adjacent to b if in order ..ab..\n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.isrightadj-Tuple{Any, Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isrightadj","text":"a is right adjacent to b if in order ..ba..\n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.maptf-Tuple{AbstractVector{T} where T<:String, Any, Function}","page":"Processing","title":"Processing.maptf","text":"Apply a function over data, resampling data to each timeframe in tfs.\n\nf: signature is (data; kwargs...)::DataFrame\ntfsum: sum the scores across multiple timeframes for every pair.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.normalize!-Tuple{Any}","page":"Processing","title":"Processing.normalize!","text":"Applies either a unitrange transform or a zscore tranform over the data in place.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.resample","page":"Processing","title":"Processing.resample","text":"Resamples ohlcv data from a smaller to a higher timeframe.\n\nstyle: how to modify the data, (arguments to the grouped dataframe) [:ohlcv]\n\n\n\n\n\n","category":"function"},{"location":"processing/#Processing.resample-Tuple","page":"Processing","title":"Processing.resample","text":"Resamples data, and saves to storage.\n\nwarning: Usually not worth it\nResampling is quite fast, so it is simpler to keep only the smaller timeframe on storage, and resample the longer ones on demand.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Processing.trail!-Tuple{Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.trail!","text":"Appends empty candles to df up to to datetime (excluded). cap: max capacity of df\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges","page":"Exchanges","title":"Exchanges","text":"","category":"section"},{"location":"exchanges/#Exchange-Types","page":"Exchanges","title":"Exchange Types","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Basic exchange types, and global exchange vars.","category":"page"},{"location":"exchanges/#API","page":"Exchanges","title":"API","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [Exchanges.ExchangeTypes]\nPages = [\"ExchangeTypes.jl\"]","category":"page"},{"location":"exchanges/#Exchange-functions","page":"Exchanges","title":"Exchange functions","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [Exchanges]\nPages = [\"exchanges.jl\", \"pairlist.jl\", \"-data.jl\"]","category":"page"},{"location":"exchanges/#Data","page":"Exchanges","title":"Data","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Extensions for the top level Data module.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [PingPong.Exchanges]\nPages = [\"data.jl\"]","category":"page"},{"location":"exchanges/#Data.load_ohlcv-Tuple{AbstractString}","page":"Exchanges","title":"Data.load_ohlcv","text":"Loads all pairs given timeframe matching global exc and config.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.load_ohlcv-Tuple{Exchange, AbstractString}","page":"Exchanges","title":"Data.load_ohlcv","text":"Loads all pairs for given exc/timeframe matching global config and zi (ZarrInstance).\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.load_ohlcv-Tuple{Union{AbstractDict, AbstractArray}, AbstractString}","page":"Exchanges","title":"Data.load_ohlcv","text":"Load given pairs from global exc and ZarrInstance.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.load_ohlcv-Tuple{}","page":"Exchanges","title":"Data.load_ohlcv","text":"Load all pairs from exchange according to config quote currency and timeframe.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.save_ohlcv-Tuple{Any, Any, Any}","page":"Exchanges","title":"Data.save_ohlcv","text":"Updates pair data of the globally set exchange.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetching","page":"Exchanges","title":"Fetching","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Helper module for downloading data off exchanges.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [Fetch]","category":"page"},{"location":"exchanges/#Fetch.SINCE_MIN_PERIOD","page":"Exchanges","title":"Fetch.SINCE_MIN_PERIOD","text":"Used to slide the since param forward when retrying fetching (in case the requested timestamp is too old).\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Base.convert-Tuple{Type{Tuple{Vector{Dates.DateTime}, Vararg{Vector{Float64}, 5}}}, PythonCall.Py}","page":"Exchanges","title":"Base.convert","text":"This is the fastest (afaik) way to convert ccxt lists to dataframe friendly format.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_loop-Union{Tuple{F}, Tuple{Function, Exchange, Any}} where F<:AbstractFloat","page":"Exchanges","title":"Fetch._fetch_loop","text":"Calls the fetc_func iteratively until the full dates range has been downloaded. NOTE: The returned data won't be exactly the number of candles expected by e.g. length(DateRange(from, to))\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_ohlcv_from_to-Tuple{Exchange, Any, Any}","page":"Exchanges","title":"Fetch._fetch_ohlcv_from_to","text":"Ensure a to date is set, before fetching.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_with_delay-Tuple{Function, Any}","page":"Exchanges","title":"Fetch._fetch_with_delay","text":"Wraps a fetching function around error handling and backoff delay. fetch_func signature: (pair::String, since::Option{Float}, limit::Float) -> PyList The converter function has to tabulate the data such that the first column is the timestamp\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_funding-Tuple{Exchange, Vector}","page":"Exchanges","title":"Fetch.fetch_funding","text":"Fetch funding rate history from exchange for a list of Derivative pairs.\n\nfrom, to: specify date period to fetch candles for.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_ohlcv-Tuple{Exchange, AbstractString, Union{AbstractSet{T}, AbstractVector{T}, Tuple{Vararg{T}}} where T}","page":"Exchanges","title":"Fetch.fetch_ohlcv","text":"Fetch ohlcv data from exchange for a list of pairs.\n\nfrom, to: Can represent a date. A negative from number implies fetching the last N=from candles.\nupdate: If true, will check for cached data, and fetch only missing candles. (false)\nprogress: if true, show a progress bar. (true)\nreset: if true, will remove cached data before fetching. (false)\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_ohlcv-Tuple{Vector{Exchange}, Any}","page":"Exchanges","title":"Fetch.fetch_ohlcv","text":"Fetch ohlcv data for multiple exchanges on the same timeframe.\n\nIt accepts:\n\na mapping of exchange instances to pairlists.\na vector of symbols for which an exchange instance will be instantiated for each element,   and pairlist will be composed according to quote currency and min_volume from PingPong.config.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.find_since-Tuple{Exchange, Any}","page":"Exchanges","title":"Fetch.find_since","text":"Should return the oldest possible timestamp for a pair, or something close to it.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.funding_data-Tuple{Exchange, AbstractString, Vararg{Any}}","page":"Exchanges","title":"Fetch.funding_data","text":"Retrieves all funding data return by exchange for symbol, or a subset.\n\nfunding_data(exc, \"BTC/USDT:USDT\")\nfunding_data(exc, \"BTC/USDT:USDT\", :fundingRate, :markPrice)\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers","page":"Interface","title":"Watchers","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"A Watcher type is an interface over a data feed. There are implementations for some 3d party apis, and exchange OHLCV data construction and order book.","category":"page"},{"location":"watchers/watchers/#User-interface","page":"Interface","title":"User interface","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"To instantiate a watcher call its related function for example ccxt_ohlcv_watcher to instantiate a watcher that tracks trades data from an exchange and builds OHLCV candles for the specified timeframe. On a watcher instance these function are currently available:","category":"page"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"get: What you mostly use watchers for. Get the underlying data monitored by the watcher, usually in a processed state (like a DataFrame), it defaults to the watcher buffer (which should keep data in a raw state).\nlength: Length of the underlying buffer.\nlast: Last raw value of the underlying buffer.\nclose: Stops the watcher and flushes the buffer.\nisstale: Should evaluate if the watcher is in a degraded state, e.g. when it can't fetch new data.\nfetch!: A watcher runs queries on specified interval, so you should only use fetch! when you want to be sure that the watcher has the latest data.\nflush!: like fetch! the watcher already flushes at predetermined intervals, use this only to ensure flushing in case of shutdown. The watcher does call flush on destruction through its finalizer, but it does so asynchronously and doesn't ensure the success of the flush operation.\ndelete!: deletes the watcher data from the storage backend used by flush! (and empties the buffer).\ndeleteat!: deletes the watcher data within a date range (and empties the buffer).\npush!: add an element to the elements the watcher subscribes to (if any).\npop!: opposite of push!.\nstop: Stops the watcher.\nstart: Restarts the watcher.","category":"page"},{"location":"watchers/watchers/#Imlementation-interface","page":"Interface","title":"Imlementation interface","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"To implement a custom watcher you have to define the functions such that dispatch happens through the watcher name interpreted as a value Val{Symbol(my_watcher_name)}. So a function needs to have a signature like _fetch!(w::Watcher, ::Val{some_symbol}).","category":"page"},{"location":"watchers/watchers/#Required","page":"Interface","title":"Required","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"_fetch! whatever fetches the data, like an http request.\n_get returns the post processed data, like a DataFrame.","category":"page"},{"location":"watchers/watchers/#Optional","page":"Interface","title":"Optional","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"_init! to perform initialization routines.\n_load! to pre-fill the watcher buffer on construction, it is only called once, runs after _init!.\n_flush! to save the watcher buffer somewhere on periodic intervals and on watcher destruction.\n_process! to update the view of the raw data, which is what the get function should return.\n_delete! to delete all the storage data of the watcher.\n_deleteat! to delete the storage data of the watcher within a date range (from, to).\n_push! watchers might manage a list of things to track (like Asset symbols).\n_pop! inverse of _push!.\n_start Executed before starting the timer.\n_stop Executed after stopping the timer.","category":"page"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"Look in the Watchers and WatchersImpls modules for helper functions:","category":"page"},{"location":"watchers/watchers/#API","page":"Interface","title":"API","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"Modules = [Watchers, Watchers.WatchersImpls]","category":"page"},{"location":"watchers/watchers/#Watchers.Watchers","page":"Interface","title":"Watchers.Watchers","text":"Watchers are data feeds, that keep track of stale data.\n\n\n\n\n\n","category":"module"},{"location":"watchers/watchers/#Watchers.Watcher","page":"Interface","title":"Watchers.Watcher","text":"Watchers manage data, they pull from somewhere, keep a cache in memory, and optionally flush periodically to persistent storage.\n\nbuffer: A CircularBuffer of default length 1000 of the watcher type parameter.\nname: The name is used for dispatching.\nhas: flags that show which callbacks are enabled between load, process and flush.\nfetch_timeout: How much time to wait for the fetcher function.\nfetch_interval: the Period with which _fetch! function will be called.\nflush_interval: the Period with which _flush! function will be called.\ncapacity: controls the size of the buffer and the processed container.\nbeacon: A condition that is notified whenever a successful fetch is performed.\nthreads: flag to enable to execute fetching in a separate thread.\nattempts: In cause of fetching failure, tracks how many consecutive fails have occurred. It resets after a successful fetch operation.\nlast_fetch: the most recent time a fetch operation failed.\nlast_flush: the most recent time the flush function was called.\n_timer: A Timer, handles calling the function that fetches the data.\n\n\n\n\n\n","category":"type"},{"location":"watchers/watchers/#Base.delete!-Tuple{Watchers.Watcher20}","page":"Interface","title":"Base.delete!","text":"Deletes all watcher data from storage backend. Also empties the buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.deleteat!-Tuple{Watchers.Watcher20, NamedTuple{(:start, :stop), Tuple{Dates.DateTime, Dates.DateTime}}}","page":"Interface","title":"Base.deleteat!","text":"Delete watcher data from storage backend within the date range specified.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.get-Tuple{Watchers.Watcher20}","page":"Interface","title":"Base.get","text":"Returns the processed view of the watcher data. Accessible also as a view property of the watcher object.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.pop!-Tuple{Watchers.Watcher20, Any, Vararg{Any}}","page":"Interface","title":"Base.pop!","text":"Remove v from the things the watcher is fetching.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.push!-Tuple{Watchers.Watcher20, Any, Vararg{Any}}","page":"Interface","title":"Base.push!","text":"Add v to the things the watcher is fetching.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._fetch!-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._fetch!","text":"Appends new data to the watcher buffer, returns true when new data is added, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._flush!-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._flush!","text":"May run after a successful fetch operation, according to the flush_interval. It spawns a task.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._get-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._get","text":"Returns the processed view of the watcher data.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._init!-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._init!","text":"Function to run on watcher initialization, it runs before _load!.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._load!-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._load!","text":"Called once on watcher creation, used to pre-fill the watcher buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._pop!-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._pop!","text":"Same as _push! but for removing elements.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._process!-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._process!","text":"Processes the watcher data, called everytime the watcher fetches new data.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._push!-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._push!","text":"If the watcher manager a group of things that it is fetching, _push! should add an element to it.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._start!-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._start!","text":"Executed before starting the timer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._stop!-Tuple{Watchers.Watcher20, Val}","page":"Interface","title":"Watchers._stop!","text":"Executed after the timer has been stopped.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.allerror-Tuple{Type, Watchers.Watcher20}","page":"Interface","title":"Watchers.allerror","text":"Get all logged watcher errors of type t.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.default_flusher-Tuple{Watchers.Watcher20, Any}","page":"Interface","title":"Watchers.default_flusher","text":"Save function for watcher data, saves to the default DATA_PATH located lmdb instance using serialization.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.default_loader-Tuple{Watchers.Watcher20, Any}","page":"Interface","title":"Watchers.default_loader","text":"Load function for watcher data, loads from the default DATA_PATH located lmdb instance using serialization.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.default_process-Tuple{Watchers.Watcher20, Function}","page":"Interface","title":"Watchers.default_process","text":"Processes the values of a watcher buffer into a dataframe. To be used with: default_init and default_get\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.fetch!-Tuple{Watchers.Watcher20}","page":"Interface","title":"Watchers.fetch!","text":"Fetches a new value from the watcher ignoring the timer. If reset is true the timer is reset and polling will resume after the watcher interval.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.flush!-Tuple{Watchers.Watcher20}","page":"Interface","title":"Watchers.flush!","text":"Flush the watcher. If wait is true, block until flush completes.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.isstale-Tuple{Watchers.Watcher20}","page":"Interface","title":"Watchers.isstale","text":"True if last available data entry is older than now() + fetch_interval + fetch_timeout.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.isstarted-Tuple{Watchers.Watcher20}","page":"Interface","title":"Watchers.isstarted","text":"True if timer is running.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.isstopped-Tuple{Watchers.Watcher20}","page":"Interface","title":"Watchers.isstopped","text":"True if timer is not running.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.lasterror-Tuple{Type, Watchers.Watcher20}","page":"Interface","title":"Watchers.lasterror","text":"Get the last logged watcher error of type t.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.lasterror-Tuple{Watchers.Watcher20}","page":"Interface","title":"Watchers.lasterror","text":"Get the last logged watcher error.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.logerror","page":"Interface","title":"Watchers.logerror","text":"Stores an error to the watcher log journal.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.pushnew!","page":"Interface","title":"Watchers.pushnew!","text":"Helper function to push a new value to the watcher buffer if it is different from the last one.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.pushstart!-Tuple{Watchers.Watcher20, Any}","page":"Interface","title":"Watchers.pushstart!","text":"Helper function to push a vector of values to the watcher buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.start!-Tuple{Watchers.Watcher20}","page":"Interface","title":"Watchers.start!","text":"Resets the watcher timer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.stop!-Tuple{Watchers.Watcher20}","page":"Interface","title":"Watchers.stop!","text":"Stops the watcher timer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.watcher-Tuple{Type, Any}","page":"Interface","title":"Watchers.watcher","text":"Instantiate a watcher.\n\nT: The type of the underlying CircularBuffer\nlen: length of the circular buffer.\nstart: If true(default), the watcher will start fetching asap.\n\nwarning: asyncio vs threads\nBoth _fetch! and _flush! callbacks assume non-blocking asyncio like behaviour. If instead your functions require high computation, pass threads=true, you will have to ensure thread safety.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"The main backend currently is Zarr. Zarr is similar to feather or parquet in that it optimizes to columnar data, or in general arrays. However it is simpler, and allows to pick different encoding schemes, and supports compression by default. More over the zarr interface can be backed by different storage layers, that can also be over the network. Compared to no/sql databases columnar storage has the drawback of having to read chunks for queries, but we are almost never are interested in scalar values, we always query a time-series of some sort, so the latency loss is a non issue.","category":"page"},{"location":"data/#Scraping","page":"Data","title":"Scraping","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"There are different ways to collect data:","category":"page"},{"location":"data/#Using-the-Scrapers-module","page":"Data","title":"Using the Scrapers module","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Currently there is support for binance and bybit archives.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using Scrapers: Scrapers as scr, BinanceData as bn\n## Download klines for ETH\nbn.binancedownload(\"eth\", market=:data, freq=:monthly, kind=:klines)\n## load them\nbn.binanceload(\"eth\", market=:data, freq=:monthly, kind=:klines)\n## Default market parameter is `:um` (usdm futures)\n\n# show all symbols that can be downloaded\nbn.binancesyms(market=:data)\n# load/download also accept `quote_currency` to filter by (default `usdt`)\nscr.selectsyms([\"eth\"], bn.binancesyms(market=:data), quote_currency=\"usdc\")","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"!! \"Downloads are cached\"     downloading the same pair path again will only downloads newer archives     if data gets corrupted pass reset=true to redownload it again. ","category":"page"},{"location":"data/#Using-the-Fetch-module","page":"Data","title":"Using the Fetch module","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"The Fetch module downloads data directly from the exchange using ccxt.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using TimeTicks\nusing Exchanges\nusing Fetch: Fetch as fe\n\nexc = getexchange!(:kucoin)\ntimeframe = tf\"1m\"\npairs = (\"BTC/USDT\", \"ETH/USDT\")\n# Will fetch the last 1000 candles, `to` can also be passed to download a specific range\nfe.fetch_candles(exc, timeframe, pairs; from=-1000)","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Fetching directly from exchanges is not recommended for smaller timeframes since they are heavily rate limited. Archives are better.","category":"page"},{"location":"data/#Using-Watchers","page":"Data","title":"Using Watchers","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"With the Watchers module you can track live data from exchanges or other data sources and store it locally.  Implemented are watchers that track OHLCV:","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using Exchanges\nusing PingPong.Watchers: Watchers as wc, WatchersImpls as wi\nexc = getexchange!(:kucoin)\n\nw = wi.ccxt_ohlcv_tickers_watcher(exc;)\nwc.start!(w)","category":"page"},{"location":"data/","page":"Data","title":"Data","text":">>> w\n17-element Watchers.Watcher20{Dict{String, NamedTup...Nothing, Float64}, Vararg{Float64, 7}}}}}\nName: ccxt_ohlcv_ticker\nIntervals: 5 seconds(TO), 5 seconds(FE), 6 minutes(FL)\nFetched: 2023-03-07T12:06:18.690 busy: true\nFlushed: 2023-03-07T12:04:31.472\nActive: true\nAttemps: 0","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"As a convention the view property of a watcher shows the processed data. In this case the candles processed by the ohlcv_ticker_watcher will be stored in a dict.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":">>> w.view\nDict{String, DataFrames.DataFrame} with 220 entries:\n  \"HOOK/USDT\"          => 5×6 DataFrame…\n  \"ETH/USD:USDC\"       => 5×6 DataFrame…\n  \"PEOPLE/USDT:USDT\"   => 5×6 DataFrame…","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"There is another OHLCV watcher based on trades, that tracks only one pair at a time.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"w = wi.ccxt_ohlcv_watcher(exc, \"BTC/USDT:USDT\"; timeframe=tf\"1m\")\nw.view\n956×6 DataFrame\n Row │ timestamp            open     high     low      close    volume  \n     │ DateTime             Float64  Float64  Float64  Float64  Float64 \n─────┼──────────────────────────────────────────────────────────────────\n...","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Other implemented watchers are the orderbook watcher, and watchers that parse data feeds from 3rd party apis.","category":"page"},{"location":"data/#API","page":"Data","title":"API","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Modules = [PingPong.Data]","category":"page"},{"location":"data/#Data.OHLCVTuple","page":"Data","title":"Data.OHLCVTuple","text":"Similar to a StructArray (and should probably be replaced by it), used for fast conversion.\n\n\n\n\n\n","category":"type"},{"location":"data/#Data.ZarrInstance","page":"Data","title":"Data.ZarrInstance","text":"Candles data is stored with hierarchy PAIR -> [TIMEFRAMES...]. A pair is a ZGroup, a timeframe is a ZArray.\n\n\n\n\n\n","category":"type"},{"location":"data/#Base.unique!-Tuple{Function, Zarr.ZArray}","page":"Data","title":"Base.unique!","text":"Remove duplicate from a zarray.\n\nIn a 2d zarray where we want values where the second column is unique:\n\nunique!(x->x[2], z)\n\n\n\n\n\n","category":"method"},{"location":"data/#Data._load_ohlcv-Tuple{Zarr.ZArray, Any}","page":"Data","title":"Data._load_ohlcv","text":"Load ohlcv pair data from zarr instance. za: The zarr array holding the data key: the name of the array to load from the zarr instance (in the format exchange/timeframe/pair) td: the timeframe (as integer in milliseconds) of the target ohlcv table to be loaded from, to: date range\n\n\n\n\n\n","category":"method"},{"location":"data/#Data._save_data-Tuple{Data.ZarrInstance, Any, Any}","page":"Data","title":"Data._save_data","text":"Saves data to a zarr array ensuring only dates seriality, not contiguity (as opposed to _save_ohlcv).\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.candleat-Tuple{DataFrames.AbstractDataFrame, Dates.DateTime}","page":"Data","title":"Data.candleat","text":"Get the candle at given date from a ohlcv dataframe as a Candle.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.candlelast-Tuple{DataFrames.AbstractDataFrame}","page":"Data","title":"Data.candlelast","text":"Get the last candle from a ohlcv dataframe as a Candle.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.candlepair-Tuple{DataFrames.AbstractDataFrame, Dates.DateTime}","page":"Data","title":"Data.candlepair","text":"Same as candleat but also fetches the previous candle, returning a Tuple{Candle, Candle}.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.chunksize-Tuple{Any}","page":"Data","title":"Data.chunksize","text":"Choose chunk size depending on size of data with a predefined split (e.g. 1/100), padding to the nearest power of 2.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.contiguous_ts-Tuple{Any, AbstractString}","page":"Data","title":"Data.contiguous_ts","text":"Checks if a timeseries has any intervals not conforming to the given timeframe.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.df!-Tuple","page":"Data","title":"Data.df!","text":"Construct a DataFrame without copying.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.empty_ohlcv-Tuple{}","page":"Data","title":"Data.empty_ohlcv","text":"An empty OHLCV dataframe.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.key_path-Tuple{Any, Any, Any}","page":"Data","title":"Data.key_path","text":"The full key of the data stored for the (exchange, pair, timeframe) combination.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.load-Tuple{Data.ZarrInstance, Any, Any, Any}","page":"Data","title":"Data.load","text":"Load a pair ohlcv data from storage. as_z: returns the ZArray\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.load_data-Tuple{Data.ZarrInstance, Any}","page":"Data","title":"Data.load_data","text":"Load data from zarr instance. zi: The zarr instance to use key: the name of the array to load from the zarr instance (full key path). type: Set to the type that zarr should use to store the data (only bits types). [Float64]. serialized: If set, data will be deserialized before returned (type is ignored). from, to: date range sz: The chunks tuple which should match the shape of the already saved data.\n\nwarning: Mismatching chunks\nLoading data with from key with wrong dimensions (ndims(sz)) or shape (columns) will reset the stored zarray.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.load_ohlcv-Tuple{Data.ZarrInstance, AbstractString, Any, Any}","page":"Data","title":"Data.load_ohlcv","text":"Load data from given zarr instance, exchange, pairs list and timeframe.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.save_ohlcv-Tuple{Data.ZarrInstance, Vararg{Any, 4}}","page":"Data","title":"Data.save_ohlcv","text":"data_col: the timestamp column of the new data (1) saved_col: the timestamp column of the existing data (1) pair: the trading pair (BASE/QUOTE string) timeframe: exchange timeframe (from exc.timeframes) type: Primitive type used for storing the data (Float64) check:\n\n:bounds (default) only checks that new data is adjacent to previous data.\n:all checks full contiguity of previous and new data.\n:none or anything else, no checks are done.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.snakecased-Tuple{AbstractString}","page":"Data","title":"Data.snakecased","text":"Normalizes or special characthers separators to _.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.to_ohlcv-Tuple{Matrix}","page":"Data","title":"Data.to_ohlcv","text":"Convert raw ccxt OHLCV data (matrix) to a dataframe.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.zdelete!-Tuple{Zarr.ZArray, Union{Nothing, Dates.DateTime}, Union{Nothing, Dates.DateTime}}","page":"Data","title":"Data.zdelete!","text":"Delete elements from a ZArray within the range of dates from_dt:to_dt.\n\nUse the select function to customize the dates vector where to index th range. Defaults to the first column of a 2D Zarray.\n\n\n\n\n\n","category":"method"},{"location":"data/#Data.zilmdb","page":"Data","title":"Data.zilmdb","text":"Create a ZarrInstance at specified path using lmdb as backend.\n\nforce: resets the underlying store.\n\n\n\n\n\n","category":"function"},{"location":"data/#Data.@as_mat-Tuple{Any}","page":"Data","title":"Data.@as_mat","text":"Redefines given variable to a Matrix with type of the underlying container type.\n\n\n\n\n\n","category":"macro"},{"location":"data/#Data.@to_mat","page":"Data","title":"Data.@to_mat","text":"Same as as_mat but returns the new matrix.\n\n\n\n\n\n","category":"macro"},{"location":"data/#Prices","page":"Data","title":"Prices","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Modules = [Prices]","category":"page"},{"location":"data/#Main.Prices.gprofit","page":"Data","title":"Main.Prices.gprofit","text":"Total profit of a ladder of trades\n\n\n\n\n\n","category":"function"},{"location":"data/#Main.Prices.price_ranges","page":"Data","title":"Main.Prices.price_ranges","text":"Given a price, output price at given ratios. (Predefined ratios - :bal,:futures,:tight,:expa)\n\n\n\n\n\n","category":"function"},{"location":"data/#Main.Prices.price_ranges-Tuple{AbstractDict, Vararg{Any}}","page":"Data","title":"Main.Prices.price_ranges","text":"Get the price range of a map of pairs, using the last available close price.\n\n\n\n\n\n","category":"method"},{"location":"engine/engine_notes/#Backtesting-overview","page":"Backtesting overview","title":"Backtesting overview","text":"","category":"section"},{"location":"engine/engine_notes/#Goals","page":"Backtesting overview","title":"Goals","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"The backtest should be able to be executed given a custom start and end date.\nThe strategy has to have access to the OHLCV and all past trade history.\nIt must be able to run during live trading.","category":"page"},{"location":"engine/engine_notes/#Main-loop","page":"Backtesting overview","title":"Main loop","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"for each timestamp:\nwhile true:\nprocess(strategy, timestamp, context)","category":"page"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"The loop is just a timestamp feeder!, and the strategy holds all the state.","category":"page"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"Because we use the TimeFrames abstraction, the step can be arbitrary, the strategy will just index into ohlcv data according to the last candle compatible with the given timestamp. This is a performance trade-off, we prefer to always index with dates, and never with integers, because it reduces the assumptions to the row data must match its timestamp (its not corrupted!) compared to spurious bugs that might arise by integer indexing.\nThe simulation is adversarial to the strategy, it is the job of the simulation to decide how much loss a trade has incurred.","category":"page"},{"location":"engine/engine_notes/#Strategy-General-Considerations","page":"Backtesting overview","title":"Strategy General Considerations","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"The strategy must account for a  tie breaker to choose which trades to perform on the same candle since we don't know which pair we observed first. In general this is a good use case for MC.","category":"page"},{"location":"engine/engine_notes/#What-does-executing-an-order-mean?","page":"Backtesting overview","title":"What does executing an order mean?","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"When the engine executes an order, it does the following for every order:","category":"page"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"Decide if order should be honored or fail\nPerform simulations, like spread, slippage, market impact.\nSignal to the strategy about failed (canceled) orders.","category":"page"},{"location":"watchers/apis/coingecko/#CoinGecko","page":"CoinGecko","title":"CoinGecko","text":"","category":"section"},{"location":"watchers/apis/coingecko/#API","page":"CoinGecko","title":"API","text":"","category":"section"},{"location":"watchers/apis/coingecko/","page":"CoinGecko","title":"CoinGecko","text":"Modules = [Watchers.CoinGecko]","category":"page"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinschart-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinschart","text":"Get close price and volume for symbol id for specified number of days.\n\ninfo: days=\"max\"\nreturns all available history.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinschart_range-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinschart_range","text":"Same as CoinGecko.coinschart but for specified timerange.\n\nfrom, to: date range boundaries.\n\nwarning: From coingecko:\nData granularity is automatic (cannot be adjusted)1 day from current time = 5 minute interval data\n1 - 90 days from current time = hourly data\nabove 90 days from current time = daily data (00:00 UTC)\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinschart_tf-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinschart_tf","text":"Pull market data range according to timeframe.\n\n5m: 1 day\n1h: 90 days\n>1h: 365 days\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinshistory","page":"CoinGecko","title":"Watchers.CoinGecko.coinshistory","text":"Get data for symbol id at specified date.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinsid-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinsid","text":"Get all current data for symbol id.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinsmarkets-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.coinsmarkets","text":"Get markets for a list of symbols, accepting params CoinGecko.Params.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinsohlc","page":"CoinGecko","title":"Watchers.CoinGecko.coinsohlc","text":"Pulls ohlc data (no volumes) according to timeframe.\n\n<=30m: 1 day\n<=4h: 30 days\n>4h: max\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinsticker-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinsticker","text":"Get all tickers (from all coingecko exchanges) for symbol id.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.derivatives-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.derivatives","text":"Returns all unexpired derivative contracts.\n\nContracts are grouped by exchange, the id being the slugified exchange name.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.derivatives_from-Tuple{Any}","page":"CoinGecko","title":"Watchers.CoinGecko.derivatives_from","text":"Fetch derivatives from specified exchange.\n\nReturns a Dict{Derivative, Dict}.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.globaldata-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.globaldata","text":"Returns global data for:\n\nvolume: total_volume (Dict{String, Float64})\nmcap_change_24h: marketcapchangepercentage24h_usd\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.idbysym-Tuple{Any, Bool}","page":"CoinGecko","title":"Watchers.CoinGecko.idbysym","text":"Get all coingecko item id matching by its symbol.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.idbysym-Tuple{Any}","page":"CoinGecko","title":"Watchers.CoinGecko.idbysym","text":"Get the first coingecko item id by its symbol.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.loadcoins!-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.loadcoins!","text":"Load all coins symbols.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.loadderivatives!-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.loadderivatives!","text":"Returns the list of all exchange ids.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.ratelimit-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.ratelimit","text":"Allows only 1 query every 3000 milliseconds seconds.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.tickers_from-Tuple{Any}","page":"CoinGecko","title":"Watchers.CoinGecko.tickers_from","text":"Fetches top 100 tickers from exchange.\n\nReturns a Dict{Asset, Dict}\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.trending-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.trending","text":"24h trending top 7 coins.\n\n\n\n\n\n","category":"method"},{"location":"engine/backtesting/#Running-a-backtest","page":"Backtesting","title":"Running a backtest","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"To run a backtest you construct a strategy and then call backtest! on it.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"The strategy loads by default a config file located in PingPong.jl/user/config.toml\nThe config defines the strategy file under include_file key in the [Example] section","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"[Example]\ninclude_file = \"strategies/Example.jl\"","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"The strategy file Example.jl defines the Example module","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"module Example\nping!(s::Strategy, ts, ctx) = pong!(...)\nend","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"info: Backtesting\nIt is based on some assumptions","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"using Engine.Strategies\nusing Engine.Executors: SimMode as bt\ns = strategy(:Example)\n# Load data in the strategy universe (you need to already have it)\nfill!(s) # or stub!(s.universe, datadict)\n# backtest the strategy within the period available from the loaded data.\nbt.backtest!(s)\n# Lets see how we fared:\ndisplay(s)\n## output\nName: Example\nConfig: 10.0(USDT)(Base Size), 100.0(USDT)(Initial Cash)\nUniverse: 3 instances, 1 exchanges\nHoldings: assets(trades): 2(977), min BTC: 23.13(USDT), max XMR: 79.611(USDT)\nPending buys: 3\nPending sells: 0\nUSDT: 32.593 (Cash)\nUSDT: 156.455 (Total)","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Our backtest says that our strategy...","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Operated on 3 assets (instances)\nExecuted 977 trades\nStarting from 100 USDT it finished with 32 USDT in cash, and 156 USDT worth of assets\nThe assets at the end with the minimum value was BTC and the one with the maximum value was XMR.\nAt the end there were 3 left open buy orders and no open sell orders.","category":"page"},{"location":"engine/backtesting/#Orders","page":"Backtesting","title":"Orders","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"To make a limit order within your strategy you call pong! just like any call to the executor. The arguments:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"trade = pong!(s, GTCOrder{Buy}, ai; price, amount, date=ts)","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Where s is your Strategy{Sim, ...} instance, ai is the AssetInstance which the order refers to (it should be one present in your s.universe) amount is the quantity in base currency and date should be the one fed to the ping! function, which during backtesting would be the current timestamp being evaluated, and during live a recent timestamp. If you look at the example strategy ts is current and ats available. The available timestamp ats is the one that matches the last candle that doesn't give you forward knowledge. The date given to the order call (pong!) must be always the current timestamp.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"A limit order call might return a trade if the order was queued correctly. If the trade hasn't completed the order, the order is queued in s.orders[ai]. If isnothing(trade) is trueit means the order failed, and was not scheduled, this can happen if the cost of the trade did not meet the asset limits, or there wasn't enough commitable cash. If instead ismissing(trade) is true it means that the order was scheduled, but that no trade has yet been performed. In backtesting this happen if the price of the order is too low(buy) or too high(sell) for the current candle high/low prices.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"At each iteration we need to check if pending orders are fullfilled, therefore we call:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"pong!(s, ts, UpdateOrders())","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Remember that we always give the current time. Also if you look at the example strategy, the call is executed right at the beginning of the ping! function. UpdateOrder should always be called exactly at the beginning and not anywhere else, otherwise during backtesting an order would be executed twice on the same timestamp (there is a check for this). This might be made implicit in future versions.","category":"page"},{"location":"engine/backtesting/#Limit-order-types","page":"Backtesting","title":"Limit order types","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Other than GTC orders there are also IOC and FOK orders:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"GTC (good till cancelled)\nIOC (immediate or cancel)\nFOK (fill or kill) All three are subtypes of a limit order, <: LimitOrder. Create them calling pong! like above:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"trade = pong!(s, IOCOrder{Buy}, ai; price, amount, date=ts)\ntrade = pong!(s, FOKOrder{Sell}, ai; price, amount, date=ts)","category":"page"},{"location":"engine/backtesting/#Checks","page":"Backtesting","title":"Checks","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Before creating an order, some checks run to sanitize the values. If for example the amount is too small, the order picks the minimum amount instead. If there isn't enough cash after the amount adjumested, the order will fail. See the ccxt docs for precision and limits.","category":"page"},{"location":"engine/backtesting/#Fees","page":"Backtesting","title":"Fees","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"The fees come from the AssetInstance fees property, which itself comes from parsing the ccxt data about that particular symbol. Every trade accounts for such fees.","category":"page"},{"location":"engine/backtesting/#Market-Orders","page":"Backtesting","title":"Market Orders","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Despite the fact that ccxt allows setting timeInForce also for market orders, because in general exchanges allow to do so, there isn't definitive information about how a market order is handled in these cases, remember that we deal with crypto so some context like open and close times days is lost. We can guess that it only matters when the orderbook doesn't have enough liquidity, otherwise they are always immediate and fully filled orders. For this reason we always consider market orders as FOK orders, and they will always have timeInForce set to FOK when executed live (through ccxt) to match the backtester.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"warning: Market orders can be surprising\nMarket orders always go through in the backtest. If the candle has no volume the order incurs in heavy slippage, and the execution price of the trades can exceed the candle high/low price.","category":"page"},{"location":"engine/backtesting/#Slippage","page":"Backtesting","title":"Slippage","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Slippage is accounted for within the trade execution.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"For limit orders there can only be positive slippage, when an order is created and the price is in your favor, the actual price of execution becomes slightly lower (for buy orders) or higher (for sell orders). The slippage formula takes into account volatility (high / low) and fill ratio (amount / volume). The higher the volume the order takes from the candle, the lower the positive slippage will be, whereas the higher the volatility, the higher the positive slippage will be. Positive slippage is only added for candles that go against the order side, which means that it will be only added on red candles for buys, and green candles for sells.\nFor market orders there can only be negative slippage. There is a minimum slippage always added (which by default corresponds to the difference between open and close (there are other formulas, check the api ref) on top of which additional skew is added based on volume and volatility.","category":"page"},{"location":"engine/engine/#Engine","page":"Executors","title":"Engine","text":"","category":"section"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Within the PingPong \"model\" we use ping! and pong! functions to communicate between strategies and executors. The executor \"pings\" the strategy, impliying that the strategy should do, or return something. The strategy instead \"pongs\" the executor, expecting it to do, or return something.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"The user of the bot, generally, only writes ping! functions within their strategies. In the case the user requires custom behaviour that is not implemented by the framework, they might be required to write pong! functions.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Other trading bots offer a set of methods that the user can implement for tuning purposes, usually tied to the super class of the strategy.  Within PingPong instead, our convention is to only deal with ping! and pong! functions, such that you know that whenever a pong! call is done from the strategy, that is a point of possible divergence between simulation and live execution.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"In fact, ping and pong functions are implemented such that they dispatch differently according to the execution mode of the strategy.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"There are 3 execution modes: ","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Sim: what the backtester uses to run the simulations\nPaper: the dry run mode, that runs the bot like it would in live, working with live data feeds and simulating order execution with live prices.\nLive: like Paper but with order execution being actually forwarded to CCXT.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Therefore if the strategy is instantiated in Sim mode, calling pong!(s, ...), where s is the strategy object of type Strategy{Sim, S, E}, the pong! function will dispatch to the Sim execution method. S and E are the other two parameters which a strategy type requires for concretization.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"S<:Symbol: the symbol that matches the module name of the strategy, like :Example\nE<:ExchangeID: The symbol already checked to match a valid CCXT exchange, which will be the exchange that the strategy will operate on.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"To realize the pong! dispatch convention, you can expect the first argument of every pong function to be the strategy object itself, while ping function might have either the strategy object or the type of the strategy as first argument (Type{Strategy{...}}).","category":"page"},{"location":"engine/engine/#API","page":"Executors","title":"API","text":"","category":"section"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Modules = [PingPong.Engine, PingPong.Engine.Instances, PingPong.Engine.Collections]","category":"page"},{"location":"engine/engine/#Base.fill!-Tuple{Collections.AssetCollection, Vararg{Any}}","page":"Executors","title":"Base.fill!","text":"Main.Engine.Instances.fill! all the instances with given timeframes data...\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Base.fill!-Tuple{Instances.AssetInstance50, Vararg{Any}}","page":"Executors","title":"Base.fill!","text":"Pulls data from storage, or resample from the shortest timeframe available.\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Data.stub!-Tuple{Collections.AssetCollection, Any}","page":"Executors","title":"Data.stub!","text":"Replaces the data of the asset instances with src which should be a mapping. Used for backtesting.\n\nsrc: The mapping, should be a pair TimeFrame => Dict{String, PairData}.\n\nExample:\n\nusing Scrapers.BinanceData as bn\nusing Strategies\nusing Exchanges\nsetexchange!(:binanceusdm)\ncfg = Config(nameof(exc.id))\nstrat = strategy!(:Example, cfg)\ndata = bn.binanceload()\nstub!(strat.universe, data)\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Instances.AssetInstance50","page":"Executors","title":"Instances.AssetInstance50","text":"An asset instance holds all known state about an asset, i.e. BTC/USDT:\n\nasset: the identifier\ndata: ohlcv series\nhistory: the trade history of the pair\ncash: how much is currently held, can be positive or negative (short)\nexchange: the exchange instance that this asset instance belongs to.\nlimits: minimum order size (from exchange)\nprecision: number of decimal points (from exchange)\n\n\n\n\n\n","category":"type"},{"location":"engine/engine/#Base.similar-Tuple{Instances.AssetInstance50}","page":"Executors","title":"Base.similar","text":"Returns a similar asset instance with cash and orders reset.\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Data.candlelast-Tuple{Instances.AssetInstance50, TimeFrames.TimeFrame, Dates.DateTime}","page":"Executors","title":"Data.candlelast","text":"Get the last available candle strictly lower than apply(tf, date)\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Instances.load!-Tuple{Instances.AssetInstance50}","page":"Executors","title":"Instances.load!","text":"Load ohlcv data of asset instance.\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Collections.AssetCollection","page":"Executors","title":"Collections.AssetCollection","text":"A collection of assets instances, indexed by asset and exchange identifiers.\n\n\n\n\n\n","category":"type"},{"location":"engine/engine/#TimeTicks.DateRange","page":"Executors","title":"TimeTicks.DateRange","text":"Makes a daterange that spans the common min and max dates of the collection.\n\n\n\n\n\n","category":"type"},{"location":"engine/engine/#Collections.bqe-Union{Tuple{T}, Tuple{DataFrames.DataFrame, T, T, T}} where T<:Symbol","page":"Executors","title":"Collections.bqe","text":"Dispatch based on either base, quote currency, or exchange.\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Collections.flatten-Tuple{Collections.AssetCollection}","page":"Executors","title":"Collections.flatten","text":"Returns a Dict{TimeFrame, DataFrame} of all the OHLCV dataframes present in the asset collection.\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Collections.iscashable-Tuple{Instruments.Cash10, Collections.AssetCollection}","page":"Executors","title":"Collections.iscashable","text":"Checks that all assets in the universe match the cash.\n\n\n\n\n\n","category":"method"},{"location":"contacts/#Github","page":"Contacts","title":"Github","text":"","category":"section"},{"location":"contacts/","page":"Contacts","title":"Contacts","text":"Submit an issue","category":"page"},{"location":"contacts/#Discord","page":"Contacts","title":"Discord","text":"","category":"section"},{"location":"contacts/","page":"Contacts","title":"Contacts","text":"join the discord chat   (Image: Discord) ","category":"page"},{"location":"misc/#Configuration","page":"Config","title":"Configuration","text":"","category":"section"},{"location":"misc/#API","page":"Config","title":"API","text":"","category":"section"},{"location":"misc/","page":"Config","title":"Config","text":"Modules = [PingPong.Misc]","category":"page"},{"location":"misc/#Misc.config","page":"Config","title":"Misc.config","text":"Global configuration instance.\n\n\n\n\n\n","category":"constant"},{"location":"misc/#Misc.fetch_limits","page":"Config","title":"Misc.fetch_limits","text":"Exchange ohlcv candles limits.\n\n\n\n\n\n","category":"constant"},{"location":"misc/#Misc.futures_exchange","page":"Config","title":"Misc.futures_exchange","text":"Some exchanges are split into different classes in ccxt.\n\n\n\n\n\n","category":"constant"},{"location":"misc/#Misc.results","page":"Config","title":"Misc.results","text":"Holds recently evaluated statements.\n\n\n\n\n\n","category":"constant"},{"location":"misc/#Misc.Config","page":"Config","title":"Misc.Config","text":"The config main structure:\n\npath: File path that loaded this config.\nmode: Execution mode (Sim, Paper, Live)\nexchange: A symbol to instantiate an exchange (a raw ExchangeID symbol)\nqc: The default quote currency.\nmargin: If margin is enabled, only margin pairs are considered.\nleverage:\n:yes : Leveraged pairs will not be filtered.\n:only : ONLY leveraged will not be filtered.\n:from : Selects non leveraged pairs, that also have a leveraged siblings.\nfutures: Selects the futures version of an Exchange and/or markets.\nmin_vol: A minimum acceptable volume, e.g. for filtering markets.\ninitial_cash: Starting cash, used when instantiating a strategy.\nmin_size: Default order size.\nmin_timeframe: The default (shortest) timeframe of the candles.\ntimeframes: Vector of sorted timeframes that the strategy uses (for loading data).\nwindow: (deprecated) The default number of candles (OHLCV).\nattrs: Generic metadata container.\nsources: mapping of modules symbols name to (.jl) file paths\n\n\n\n\n\n","category":"type"},{"location":"misc/#Base.copy-Tuple{Misc.Config}","page":"Config","title":"Base.copy","text":"Shallow copies the config, and top level containers fields timeframes and attrs.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Base.empty!-Tuple{Misc.Config}","page":"Config","title":"Base.empty!","text":"Reset config to default values.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc._instantiate_workers-Tuple{Any}","page":"Config","title":"Misc._instantiate_workers","text":"Instantiate new workers if the current number mismatches the requested one.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.after-Tuple{AbstractVector, Any}","page":"Config","title":"Misc.after","text":"Returns a view of the sorted vector v, indexed using rangeafter.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.before-Tuple{AbstractVector, Any}","page":"Config","title":"Misc.before","text":"Returns a view of the sorted vector v, indexed using rangebefore.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.between-Tuple{AbstractVector, Any, Any}","page":"Config","title":"Misc.between","text":"Returns a view of the sorted vector v, indexed using rangebetween.\n\njulia> between([1, 2, 3, 3, 3], 3, 3; strict=true)\n0-element view(::Vector{Int64}, 6:5) with eltype Int64\njulia> between([1, 2, 3, 3, 3], 1, 3; strict=true)\n1-element view(::Vector{Int64}, 2:2) with eltype Int64:\n 2\njulia> between([1, 2, 3, 3, 3], 2, 3; strict=false)\n2-element view(::Vector{Int64}, 3:4) with eltype Int64:\n 3\n 3\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.config!-Tuple{Union{String, Symbol}}","page":"Config","title":"Misc.config!","text":"Parses the toml file and populates the config cfg (defaults to global config).\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.config_path-Tuple{}","page":"Config","title":"Misc.config_path","text":"The config path (TOML), relative to the current project directory.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.rangeafter-Tuple{AbstractVector, Any}","page":"Config","title":"Misc.rangeafter","text":"Returns the range index of sorted vector v for all the values after d. when strict is false, the range will start after the first occurence of d.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.rangebefore-Tuple{AbstractVector, Any}","page":"Config","title":"Misc.rangebefore","text":"Returns the range index of sorted vector v for all the values before d. when strict is false, the range will start before the last occurence of d.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.rangebetween-Tuple{AbstractVector, Any, Any}","page":"Config","title":"Misc.rangebetween","text":"Returns the range index of sorted vector v for all the values before d. Argument strict behaves same as rangeafter and rangebefore.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.@as_dfdict","page":"Config","title":"Misc.@as_dfdict","text":"Binds a mrkts variable to a Dict{String, DataFrame} where the keys are the pairs names and the data is the OHLCV data of the pair.\n\n\n\n\n\n","category":"macro"},{"location":"misc/#Misc.@lev!-Tuple{}","page":"Config","title":"Misc.@lev!","text":"Toggle config leverage flag\n\n\n\n\n\n","category":"macro"},{"location":"misc/#Misc.@margin!-Tuple{}","page":"Config","title":"Misc.@margin!","text":"Toggle config margin flag.\n\n\n\n\n\n","category":"macro"},{"location":"misc/#Progress-bar","page":"Config","title":"Progress bar","text":"","category":"section"},{"location":"misc/","page":"Config","title":"Config","text":"Modules = [Pbar]","category":"page"},{"location":"misc/#Pbar.Pbar","page":"Config","title":"Pbar.Pbar","text":"Progress bar wrapper.\n\n\n\n\n\n","category":"module"},{"location":"misc/#Pbar.frequency!-Tuple{Any}","page":"Config","title":"Pbar.frequency!","text":"Set the update frequency globally.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Pbar.pbclose!","page":"Config","title":"Pbar.pbclose!","text":"Terminates the progress bar.\n\n\n\n\n\n","category":"function"},{"location":"misc/#Pbar.transient!","page":"Config","title":"Pbar.transient!","text":"Toggles pbar transient flag\n\n\n\n\n\n","category":"function"},{"location":"misc/#Pbar.@pbar!","page":"Config","title":"Pbar.@pbar!","text":"Instantiate a progress bar:\n\ndata: length(data) determines the bar total\nunit: what unit the display\ndesc: description will appear over the progressbar\n\n\n\n\n\n","category":"macro"},{"location":"misc/#Pbar.@pbupdate!","page":"Config","title":"Pbar.@pbupdate!","text":"Single update to the progressbar with the new value.\n\n\n\n\n\n","category":"macro"},{"location":"misc/#Pbar.@withpbar!-Tuple{Any, Vararg{Any}}","page":"Config","title":"Pbar.@withpbar!","text":"Same as @pbar! but with implicit closing.\n\n\n\n\n\n","category":"macro"},{"location":"analysis/#Analysis","page":"Indicators","title":"Analysis","text":"","category":"section"},{"location":"analysis/","page":"Indicators","title":"Indicators","text":"This module is pretty much a playground of functions that I am using/used, most likely of very little interest.","category":"page"},{"location":"analysis/#API","page":"Indicators","title":"API","text":"","category":"section"},{"location":"analysis/","page":"Indicators","title":"Indicators","text":"Modules = [Analysis]","category":"page"},{"location":"analysis/#Analysis.fltsummary-Tuple{AbstractVector{Tuple{AbstractFloat, Data.PairData}}}","page":"Indicators","title":"Analysis.fltsummary","text":"Return the summary of a filtered vector of pairdata.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Analysis.mark!-Tuple{}","page":"Indicators","title":"Analysis.mark!","text":"Loads the Mark module.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Base.filter-Tuple{Function, AbstractDict, Real, Real}","page":"Indicators","title":"Base.filter","text":"Filters a list of pairs using a predicate function. The predicate functions must return a Real number which will be used for sorting.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Mark","page":"Indicators","title":"Mark","text":"","category":"section"},{"location":"analysis/#MVP","page":"Indicators","title":"MVP","text":"","category":"section"},{"location":"analysis/","page":"Indicators","title":"Indicators","text":"Modules = [MVP]","category":"page"},{"location":"analysis/#MVP.MVP","page":"Indicators","title":"MVP.MVP","text":"Momentum, volume, price indicator.\n\n\n\n\n\n","category":"module"},{"location":"analysis/#MVP.discrete_mvp-Tuple{AbstractDict{String, Data.PairData}}","page":"Indicators","title":"MVP.discrete_mvp","text":"\n\n\n\n","category":"method"},{"location":"analysis/#MVP.is_mvp-Tuple{AbstractVector, AbstractVector}","page":"Indicators","title":"MVP.is_mvp","text":"Returns the mvp-ness of a pair as a sum of each condition ratio weighted by weights. If real=false it will return a Bool indicating if the pair passes the given ratios.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#MVP.momentum-Tuple{AbstractVector}","page":"Indicators","title":"MVP.momentum","text":"Ratio is the minimum number of green candles required.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#MVP.volume-Tuple{AbstractVector}","page":"Indicators","title":"MVP.volume","text":"Ratio is the minimum percent increment of volume from the first half of the series.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Short","page":"Indicators","title":"Short","text":"","category":"section"},{"location":"analysis/","page":"Indicators","title":"Indicators","text":"Modules = [Short]","category":"page"},{"location":"analysis/#Long","page":"Indicators","title":"Long","text":"","category":"section"},{"location":"analysis/","page":"Indicators","title":"Indicators","text":"Modules = [Long]","category":"page"},{"location":"stats/#Stats","page":"Stats","title":"Stats","text":"","category":"section"},{"location":"stats/#API","page":"Stats","title":"API","text":"","category":"section"},{"location":"stats/","page":"Stats","title":"Stats","text":"Modules = [Stats]","category":"page"},{"location":"stats/#Stats.resample_trades","page":"Stats","title":"Stats.resample_trades","text":"Aggregates all trades of a strategy in a single dataframe\n\nbyinstance: (trades_df, ai) -> nothing can modify the dataframe of a single instance before it is appended to the full df.\n\n\n\n\n\n","category":"function"},{"location":"stats/#Stats.resample_trades-Tuple{Instances.AssetInstance50, Any}","page":"Stats","title":"Stats.resample_trades","text":"Resamples trades data from a smaller to a higher timeframe.\n\n\n\n\n\n","category":"method"},{"location":"stats/#Stats.trades_balance","page":"Stats","title":"Stats.trades_balance","text":"Plots the trade history for all the assets in a strategy.\n\nreturn_all[true]: similar to the function for single assets, plus:\n\ncum_quote: the balance of cash for each timestamp\ncum_value_balance: the balance of all held assets in quote currency for each timestamp.\n\nbyasset[false]: also return a column that tracks the value balance by asset for each timestamp normalize_timeframes:\n\n\n\n\n\n","category":"function"},{"location":"stats/#Stats.trades_balance-Tuple{Instances.AssetInstance50}","page":"Stats","title":"Stats.trades_balance","text":"Replays the trade history of a single asset instance.\n\nreturn_all: if true returns a dataframe where:\n\nbase/quote_balance the volume generated by the trades that happened at that timestamp.\n:cum_total represents the total balance held for each timestamp.\n:cum_value_balance represents the value in quote currency of the asset for each timestamp.\n\nwarning: For single assets only\nIf your strategy trades multiple assets the profits returned by this function won't match the strategy actual holdings since calculation are done only w.r.t this single asset.\n\n\n\n\n\n","category":"method"},{"location":"stats/#Stats.tradesvolume!-Tuple{Any}","page":"Stats","title":"Stats.tradesvolume!","text":"Buys substract quote currency, while sells subtract base currency\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#CoinPaprika","page":"CoinPaprika","title":"CoinPaprika","text":"","category":"section"},{"location":"watchers/apis/coinpaprika/#API","page":"CoinPaprika","title":"API","text":"","category":"section"},{"location":"watchers/apis/coinpaprika/","page":"CoinPaprika","title":"CoinPaprika","text":"Modules = [Watchers.CoinPaprika]","category":"page"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.addcalls!","page":"CoinPaprika","title":"Watchers.CoinPaprika.addcalls!","text":"Manually add available api calls (mostly for debugging).\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.betas-Tuple{}","page":"CoinPaprika","title":"Watchers.CoinPaprika.betas","text":"Returns coins betas in a dataframe compatible type.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.coin_exchanges-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.coin_exchanges","text":"Get all exchanges for specified coin.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.coin_markets-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.coin_markets","text":"Returns all markets for give coin (interpreted as base currency).\n\nwarning: Expensive call\nDon't call too often.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.coin_ohlcv-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.coin_ohlcv","text":"Coin ohlcv (last day).\n\nincomplete: if true returns the (today) incomplete candle.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.hourly","page":"CoinPaprika","title":"Watchers.CoinPaprika.hourly","text":"Returns historical hourly tick values for the last day.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.idbysym-Tuple{Any, Bool}","page":"CoinPaprika","title":"Watchers.CoinPaprika.idbysym","text":"Get all coinpaprika item id matching by its symbol.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.idbysym-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.idbysym","text":"Get the first coinpaprika item id by its symbol.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.loadcoins!-Tuple{}","page":"CoinPaprika","title":"Watchers.CoinPaprika.loadcoins!","text":"Load all coin ids.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.loadexchanges!-Tuple{}","page":"CoinPaprika","title":"Watchers.CoinPaprika.loadexchanges!","text":"Load market ids.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.markets","page":"CoinPaprika","title":"Watchers.CoinPaprika.markets","text":"Fetch all markets for specified exchange.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.ratelimit-Tuple{}","page":"CoinPaprika","title":"Watchers.CoinPaprika.ratelimit","text":"CoinPaprika free plan is 25k queries per month, which is 1q/25s.\n\nOn every call we check when the last query was performed, and add available queries that weren't used on a counter, to allow for bursts.\n\nwarning: Not precise\nCoinpaprika does not expose credits consumed by each endpoint, so we assume all calls are equals (2/min).\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.ticker-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.ticker","text":"Fetch ticker for specified coin.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.tickers","page":"CoinPaprika","title":"Watchers.CoinPaprika.tickers","text":"Fetch quotes for all pairs, includes coinpaprika beta metric.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.twitter-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.twitter","text":"Get last ~50 tweets for coin.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinmarketcap/#CoinMarketCap","page":"CoinMarketCap","title":"CoinMarketCap","text":"","category":"section"},{"location":"watchers/apis/coinmarketcap/#API","page":"CoinMarketCap","title":"API","text":"","category":"section"},{"location":"watchers/apis/coinmarketcap/","page":"CoinMarketCap","title":"CoinMarketCap","text":"Modules = [Watchers.CoinMarketCap]","category":"page"},{"location":"watchers/apis/coinmarketcap/#Watchers.CoinMarketCap.credits-Tuple{}","page":"CoinMarketCap","title":"Watchers.CoinMarketCap.credits","text":"Fetch remaining credits.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinmarketcap/#Watchers.CoinMarketCap.listings","page":"CoinMarketCap","title":"Watchers.CoinMarketCap.listings","text":"Fetch all coin listings.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinmarketcap/#Watchers.CoinMarketCap.quotes-Tuple{AbstractArray{String}}","page":"CoinMarketCap","title":"Watchers.CoinMarketCap.quotes","text":"Call quotes to get data for a specific list of currencies.\n\nPassing values of type Symbol will use the symbol parameter, while String will use the slug parameter.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinmarketcap/#Watchers.CoinMarketCap.setapikey!","page":"CoinMarketCap","title":"Watchers.CoinMarketCap.setapikey!","text":"Sets coinmarketcap api key.\n\nfrom env var CMC_API_KEY\nor from config key coinmarketcap_apikey\n\n\n\n\n\n","category":"function"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Precompilation-fails","page":"Troubleshooting","title":"Precompilation fails","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"A repo update might have added some dependencies. If there are problems with precompilation ensure all the packages are resolved.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"include(\"resolve.jl\")\nrecurse_projects() # optional ;update=true","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you are not doing it already, try to load the repl passing the project as arg, e.g.:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"julia --project=.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Avoid starting a repl and then calling Pkg.activate(\".\") when precompiling.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Precompilation of things that depend on python (like exchange functions) can cause segfaults. Some famous suspects that can cause dangling pointers in the precompiled code are:\nglobal caches, like the tickers_cache, since the content of global constants is serialized by precompilation, make sure that those constants are empty during precompilation.\nmacros like @py can rewrite code putting in place python objects. Avoid use of those macros in functions that you want precompiled.\nIf some package keeps skipping precompilation, it is likely that the JULIA_NOPRECOMP env var contains dependencies of such package.","category":"page"},{"location":"troubleshooting/#Python-can't-find-modules","page":"Troubleshooting","title":"Python can't find modules","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If python complains about missing dependencies, while in the julia REPL, with this repository as the activated project, do this:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"; find ./ -name .CondaPkg | xargs -I {} rm -r {} # Delete existing conda environments\nusing Python # Loads our python wrapper around CondaPkg which fixes `PYTHONPATH` env var\nimport Pkg; Pkg.instantiate()","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Alternatively force CondaPkg env resolution, from julia --project.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using Python.PythonCall.C.CondaPkg\nCondaPkg.resolve(force=true)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"restart the REPL.","category":"page"},{"location":"troubleshooting/#It-is-unresponsive","page":"Troubleshooting","title":"It is unresponsive","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If the exchange instance has been idle for quite a while the connection might have been closed. It should fail according to the ccxt exchange timeout, although more often than not it takes longer. After the inevitable timeout error the connection is re-established and subsequent functions that rely on api calls should become responsive again.","category":"page"},{"location":"troubleshooting/#Can't-save-data","page":"Troubleshooting","title":"Can't save data","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you are using LMDB with zarr (which is default) the initial db size is 64MB. To increase it:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using Data\nzi = zilmdb()\nData.mapsize!(zi, 1024) # This will set the max DB size to 1GB\nData.mapsize!!(zi, 100) # Double bang (!!) will _add_ to the previous mapsize (in this case 1.1GB)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Whenever the stored data reaches the mapsize, you have to increase it.","category":"page"},{"location":"troubleshooting/#Plotting-tooltips-are-unaligned","page":"Troubleshooting","title":"Plotting tooltips are unaligned","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Likely a bug with WGLMakie, use GLMakie instead:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using GLMakie\nGLMakie.activate!()","category":"page"},{"location":"devdocs/#Precompilations","page":"Devdocs","title":"Precompilations","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Functions that should be precompiled","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Python: clearpath!\nData: ZarrInstance, ZGroup, zopen, get_zgroup\nMisc: empty!(::Config)\nCPython __init__(?)","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Precompilation can be skipped for some modules, by setting JULIA_NOPRECOMP env var:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"ENV[\"JULIA_NOPRECOMP\"] = (:PingPong, :Scrapers, :Engine, :Watchers, :Plotting, :Stats)","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"or use direnv, (see the .envrc in the repository). Setting JULIA_NOPRECOMP=all disables precompilation entirely for some packages, it should be used only when modifying low level pieces of the modules stack. When switching between all, and custom lists remember to purge the compile cache:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"include(\"resolve.jl\")\npurge_compilecache() # If you pass a local package name it will only purge that package comp cache","category":"page"},{"location":"devdocs/#Methods-invalidations","page":"Devdocs","title":"Methods invalidations","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"The sequence of using ... statements to load modules can be important to consider, although only for the first instance for a particular module is critical. That's because when a module is loaded, methods insertion can trigger invalidation. If you order the modules loading from the most likley to invalidate, to the least one, less methods will be invalidated and the top module will load faster.  For example in case of modules that depend on the Python, making python the top most statemenet can improve loading times, e.g.:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"# load invalidation heavy modules first\nusing Python\nusing Ccxt\n# load lightweight modules later\nusing Timeticks\nusing Lang","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Invalidation heavy modules list:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Python\nCcxt (starts the python async loop)\nData (depends on Zarr and DataFrames)\nPlots (makie dependency)","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"In general if one of our local package depends on some heavy package, the chances that it will trigger many methods invalidations is high. This is also why it is important to always add an external module to 1 and only 1 local package and use the local package as dependency to other local packages, e.g.:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"We choose to make DataFrames a dependency to the local package Data, but we want to use the DataFrames module from our Stats package. We should not add DataFrames the deps of Stats, instead we Data and import DataFrames from Data like so:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"module Stats\n\nusing Data.DataFrames\n\n# ...\nend","category":"page"},{"location":"devdocs/#Adding-dependencies","page":"Devdocs","title":"Adding dependencies","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Only add a dependency to one of the subpackages, when using the same dependency from another subpackage, add the subpackage that already has that dependency instead of the dependency itself.","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"When adding using or imports statements inside packages you must consider their order. The rule of thumb is to always import from the most downstream package to the most upstream. This reduces the amount of invalidations happening as packages are inserted into the method tables.","category":"page"},{"location":"customizations/#Extending-the-framework/bot","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"","category":"section"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"We have parametrized types for strategies, assets/instances, orders, and trades. The strategy parametrization is what allows us to implement the ping pong model by separating simulations from live executions, the rest can be used to implement custom logic behaviour.","category":"page"},{"location":"customizations/#Custom-orders","page":"Extending the framework/bot","title":"Custom orders","text":"","category":"section"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"For example this is a sketch on how we can implement an OCO order type for simulations:","category":"page"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"using OrderTypes: OrderType, @deforders\nabstract type OCOOrderType{S} <: OrderType{S}\n@deforders OCO","category":"page"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"We can use the limitorder constructor function as template and tweak it for what we would need for an OCO order:","category":"page"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"const _OCOOrderState = NamedTuple{(:committed, :filled, :trades, :twin), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Ref{OCOOrder{S where S}}}}\nfunction oco_order_state(\n    committed::Vector{T}, filled=[0.0], trades=Trade[]\n) where {T}\n    _OCOOrderState((committed, filled, trades, Ref{OCOOrder}()))\nend\nfunction ocoorder(\n    ai::AssetInstance,\n    ::SanitizeOff\n    ;\n    price_lower,\n    amount_lower,\n    price_upper,\n    amount_upper,\n    committed_lower,\n    committed_upper,\n    date,\n)\n    ismonotonic(price_lower, price_upper) || return nothing\n    iscost(ai, amount_lower, price_lower) || return nothing\n    iscost(ai, amount_upper, price_upper) || return nothing\n    lower_order = OrderTypes.Order(\n        ai,\n        OCOOrderType{Sell};\n        date,\n        price_lower,\n        amount_lower,\n        committed_lower,\n        attrs=oco_order_state(nothing, nothing, committed),\n    )\n    upper_order = OrderTypes.Order(\n        ai,\n        OCOOrderType{Buy};\n        date,\n        price_lower,\n        amount_lower,\n        committed_lower,\n        attrs=oco_order_state(nothing, nothing, committed),\n    )\n    lower_order.attrs[:twin] = upper_order\n    upper_order.attrs[:twin] = lower_order\n    return lower_order\nend","category":"page"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"Now we add two pong! functions, one for order creation, and one for updates.","category":"page"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"@doc \"Creates a simulated oco order.\"\nfunction pong!(\n    s::Strategy{Sim}, ::Type{Order{<:OCOOrderType}}, ai; date, kwargs...\n)\n    o = ocoorder(s, ai; date, kwargs...)\n    isnothing(o) && return nothing\n    iscommittable(s, o, ai) || return nothing\n    ## add logic to execute and return trades...\nend\n@doc \"Progresses a simulated oco order.\"\nfunction pong!(\n    s::Strategy{Sim}, ::Type{<:Order{OCOOrderType}}, date::Datetime, ai; kwargs...\n)\n    o = ocoorder(s, ai; date, kwargs...)\n    isnothing(o) && return nothing\n    iscommittable(s, o, ai) || return nothing\n    iscommittable(s, o.attrs.twin, ai) || return nothing\n    ## add logic to execute and return trades...\nend","category":"page"},{"location":"customizations/#Custom-instruments","page":"Extending the framework/bot","title":"Custom instruments","text":"","category":"section"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"Instruments are also extendable, we have a simpler Asset and Derivative which are both subtypes of AbstractAsset, they are constructed following the CCXT naming scheme (QUOTE/BASE:SETTLE), the most basic expectation for instruments is that they have a baseand _quote_ currency.","category":"page"},{"location":"customizations/#Instances-and-exchanges","page":"Extending the framework/bot","title":"Instances and exchanges","text":"","category":"section"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"Asset instances are parametrized with the type of asset (asset,derivative...) and an exchange. The parametrization over ExchangeID allows us to customize the execution for particular exchanges.","category":"page"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"For example if in live mode we wanted to support OCO orders differently across exchanges we could write pong! functions that dispatch depending on the exchange parameter of the asset instance.","category":"page"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"function pong!(\n    s::Strategy{Live}, ::Type{Order{<:OCOOrderType}}, ai::AssetInstance{A where A, ExchangeID{:bybit}}; date, kwargs...\n)\n### Call some private method of the ccxt exchange class to execute the order\nend","category":"page"},{"location":"customizations/","page":"Extending the framework/bot","title":"Extending the framework/bot","text":"The above function would only dispatch to asset instances belonging to the exchange bybit.","category":"page"},{"location":"strategy/#Strategy-interface","page":"Strategies","title":"Strategy interface","text":"","category":"section"},{"location":"strategy/#Load-a-strategy","page":"Strategies","title":"Load a strategy","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The strategy is instantiated by loading a julia module at runtime.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"using PingPong\ncfg = Config(:kucoin) # Load the configuration, choosing kucoin as exchange\nstrategy!(:Example, cfg) # Load the Example strategy","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The strategy is looked up inside the config under the sources key:","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"# Example config\n[kucoin]\nfutures = true\n[sources]\nExample = \"cfg/strategies/Example.jl\" # the name of the module","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The key is the name of the module (in this case Example) which will be imported from the included file \"cfg/strategies/Example.jl\".","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"After the strategy module is imported the strategy is instantiated by calling the ping!(::Type{S}, ::LoadStrategy, cfg) function.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"> typeof(s)\nEngine.Strategies.Strategy37{:Example, ExchangeTypes.ExchangeID{:kucoin}(), :USDT}","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"See here how the load method is defined.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"module Example\nusing Engine.Strategies\nusing ExchangeTypes\n\nconst NAME = :Example\nconst EXCID = ExchangeID(:bybit)\nconst S{M} = Strategy{M,NAME,typeof(EXCID)}\nconst TF = tf\"1m\"\n\nfunction ping!(::Type{S}, ::LoadStrategy, config)\n    assets = marketsid(S)\n    s = Strategy(Example, assets; config)\n    s\nend\n\nend","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"See that the load method dispatches on the strategy type with cfg as argument of type Misc.Config.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"As a rule of thumb if the method should be called before the strategy is construct, then it dispatches to the strategy type (Type{S}), otherwise the strategy instance (S). For convention the module property S of your strategy module, declares the strategy type (const S = Strategy{name, exc}).","category":"page"},{"location":"strategy/#Strategy-interface-2","page":"Strategies","title":"Strategy interface","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"ping!(::Type{S}, ::LoadStrategy, config): loads the strategy\nping!(::S, ::WarmupPeriod): returns how much data the strategy needs on startup\nping!(::S, ::DateTime, ::Context): the \"main\" strategy function, called once per candle in backtest and once per throttle during live.","category":"page"},{"location":"strategy/#API","page":"Strategies","title":"API","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"Engine.Strategy","category":"page"},{"location":"strategy/#Strategies.Strategy","page":"Strategies","title":"Strategies.Strategy","text":"The strategy is the core type of the framework.\n\nThe strategy type is concrete according to:\n\nName (Symbol)\nExchange (ExchangeID), read from config\nQuote cash (Symbol), read from config\n\nThe exchange and the quote cash should be specified from the config, or the strategy module.\n\nuniverse: All the assets that the strategy knows about\nholdings: assets with non zero balance.\norders: active orders\ntimeframe: the smallest timeframe the strategy uses\ncash: the quote currency used for trades\n\nConventions for strategy defined attributes:\n\nNAME: the name of the strategy could be different from module name\nS: the strategy type.\nTF: the smallest timeframe that the strategy uses\n\n\n\n\n\n","category":"type"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"Modules = [Engine.Strategies]\nFilter = filter_strategy","category":"page"},{"location":"strategy/#Misc.execmode-Union{Tuple{Strategies.Strategy{M}}, Tuple{M}} where M<:Misc.ExecMode","page":"Strategies","title":"Misc.execmode","text":"Returns the strategy execution mode.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.assets-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.assets","text":"Assets loaded by the strategy.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.default!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.default!","text":"Set strategy defaults.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.exchange-Tuple{Type{<:Strategies.Strategy}}","page":"Strategies","title":"Strategies.exchange","text":"Strategy main exchange id.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.freecash-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.freecash","text":"Cash that is not committed, and therefore free to use for new orders.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.instances-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.instances","text":"Strategy assets instance.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.ping!-Tuple{Strategies.Strategy, Any, Any, Vararg{Any}}","page":"Strategies","title":"Strategies.ping!","text":"Called on each timestep iteration, possible multiple times. Receives:\n\ncurrent_time: the current timestamp to evaluate (the current candle would be current_time - timeframe).\nctx: The context of the executor.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.ping!-Tuple{Strategies.Strategy, Strategies.WarmupPeriod}","page":"Strategies","title":"Strategies.ping!","text":"How much lookback data the strategy needs.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.ping!-Tuple{Type{<:Strategies.Strategy}, Strategies.LoadStrategy, Any}","page":"Strategies","title":"Strategies.ping!","text":"Called to construct the strategy, should return the strategy instance.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.reload!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.reload!","text":"Reloads ohlcv data for assets already present in the strategy universe.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.reset!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.reset!","text":"Resets strategy.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategies.tradesedge-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.tradesedge","text":"Returns the first and last trade of any asset in the strategy universe.\n\n\n\n\n\n","category":"method"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The Plotting module is based on Makie. Backends are not included in the package dependencies so you need to add one yourself:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"] add GLMakie\nusing GLMakie\n# or\n] add WGLMakie\nusing WGLMakie","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"PingPong provides recipes for plotting:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"OHLCV\nFine grained trades history\nAggregated trades history with volume and balance.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"info: Interactivity\nPlots generated using makie interactive backends (GLMakie and WGLMakie) can be dragged and zoomed. There are tooltips (on hover) for candles, trades and balance plots.","category":"page"},{"location":"plotting/#OHLCV","page":"Plotting","title":"OHLCV","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"We plot ohlcv data using candlesticks, colored in red/green, and volume bars in the background.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Plotting\nusing Scrapers.BinanceData\ndf = binanceload(\"eth\").data\nfig = Plotting.ohlcv(df)\ndisplay(fig)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: OHLCV Plot)","category":"page"},{"location":"plotting/#Trades-history","page":"Plotting","title":"Trades history","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"We plot trades history as triangles pointing up for buys and down for sells.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Lang\nusing Strategies\nusing Engine.Executors.SimMode: SimMode as bt\ns = st.strategy(:Example)\nai = s.universe[m\"eth\"].instance\nbt.backtest!(s)\n# Plot the first 100 trades for the first asset matching symbol \"eth\"\nfig = Plotting.tradesticks(s, m\"eth\", to=100)\ndisplay(fig)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: TradesTicks)","category":"page"},{"location":"plotting/#Aggregated-trades-history-for-single-asset","page":"Plotting","title":"Aggregated trades history for single asset","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For a high level view of the trades density there is the balloons function. It aggregates all trades that have happened in a single timeframe. The bigger the circle the higher is the volume. Timeframes with positive volume are considered sells and the opposite for buys. The less transparent the circle the more trades have happened in the timeframe. The plot at the bottom shows the balance, in quote currency held. The first band (orange) is actual cash (from Strategy.cash) while the other (blue) is the value of held assets in quote currency (AssetInstance.cash * price).","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Aggreggate trades within 1 day for the first asset matching \"eth\".\nPlotting.balloons(s, m\"eth\", tf=tf\"1d\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Ballons)","category":"page"},{"location":"plotting/#Aggregated-trades-history-for-multiple-assets","page":"Plotting","title":"Aggregated trades history for multiple assets","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"When plotting aggregated history for all strategy assets, we overlay balloons over the priceline of each asset. Opacity and balloon radius properties are the same as for single asset plots. Alternatively passing a symbol or a dataframe as benchmark kwarg will plot all aggregations over that single asset OHLCV data.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Aggreggate trades within 1 day for all the assets in the strategy universe\nPlotting.balloons(s, tf=tf\"1w\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Ballons Multi)","category":"page"},{"location":"plotting/#Custom-indicators","page":"Plotting","title":"Custom indicators","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For plotting a moving average we can use the line_indicator function.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"analyze!()\nusing Indicators\nm7 = Indicators.sma(df.close, n=7)\nm14 = Indicators.sma(df.close, n=14)\nfig = Plotting.ohlcv(df);\nfig = line_indicator!(fig, m7, m14)\ndisplay(fig)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Line Indicator)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For channels/envelopes we can use the channel_indicator function.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"bb = Indicators.bbands(df.close)\nPlotting.channel_indicator(df, eachcol(bb)...)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Channel Indicator)","category":"page"},{"location":"plotting/#API","page":"Plotting","title":"API","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Modules = [ Plotting ]\nPrivate = false\nPublic = true","category":"page"},{"location":"plotting/#Plotting.balloons-Tuple{Strategies.Strategy, Instances.AssetInstance50}","page":"Plotting","title":"Plotting.balloons","text":"balloons(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance50;\n    tf,\n    force\n) -> Makie.Figure\n\n\nPlots all trades for a single asset instance, aggregating data to the provided timeframe [1d].\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Plotting.balloons-Tuple{Strategies.Strategy}","page":"Plotting","title":"Plotting.balloons","text":"balloons(\n    s::Strategies.Strategy;\n    benchmark,\n    tf,\n    force\n) -> Makie.Figure\n\n\nPlots all trades for all strategy assets, aggregating data to the provided timeframe [1d].\n\nbenchmark[:all]: either\nDataFrame ohlcv data over which to plot trades.\n:all to plot every asset price overlapping each one.\nor a specific symbol to load ohlcv data from storage.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Plotting.ohlcv","page":"Plotting","title":"Plotting.ohlcv","text":"ohlcv(df::DataFrames.AbstractDataFrame) -> Makie.Figure\nohlcv(\n    df::DataFrames.AbstractDataFrame,\n    tf;\n    kwargs...\n) -> Makie.Figure\n\n\nPlots ohlcv data from dataframe df, resampling to tf.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Plotting.ohlcv!","page":"Plotting","title":"Plotting.ohlcv!","text":"ohlcv!(\n    fig::Makie.Figure,\n    df::DataFrames.AbstractDataFrame\n) -> Makie.Figure\nohlcv!(\n    fig::Makie.Figure,\n    df::DataFrames.AbstractDataFrame,\n    tf\n) -> Makie.Figure\n\n\nSame as ohlcv but over input Figure\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Plotting.tradesticks","page":"Plotting","title":"Plotting.tradesticks","text":"tradesticks(s::Strategies.Strategy) -> Makie.Figure\ntradesticks(\n    s::Strategies.Strategy,\n    fig::Makie.Figure,\n    args...;\n    kwargs...\n) -> Makie.Figure\n\n\nPlots a subset of trades history of an asset instance.\n\nfrom: the first index in the trade history to plot [1]\nto: the last index in the trade history to plot [lastindex]\nforce: plots very large dataframes [false]\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Plotting.tradesticks!","page":"Plotting","title":"Plotting.tradesticks!","text":"Same as tradesticks over an input Figure.\n\n\n\n\n\n","category":"function"},{"location":"#Quickstart","page":"Introduction","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Launch julia and activate the package:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"git clone https://github.com/untoreh/PingPong.jl\ncd PingPong.jl\njulia --project=.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Instantiate dependencies:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg: Pkg\nPkg.instantiate()\nusing PingPong","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Load the default strategy, which you can look up at ./user/strategies/Example.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Engine.Strategies\ns = strategy(:Example)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Download some data:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Instruments\npairs = raw.(s.universe.data.asset)\nusing Scrapers: BinanceData as bn\nbn.binancedownload(pairs)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Load the data into the strategy universe:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Engine.Collections: stub!\nlet data = bn.binanceload(pairs)\n    stub!(s.universe, data)\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Backtest the strategy within the period available from the loaded data.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Engine.Executors.SimMode: SimMode as bt\nbt.backtest!(s)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Plot the simulated trades:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PingPong.plots!()\n","category":"page"},{"location":"#Packages","page":"Introduction","title":"Packages","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Engine: The actual backtest engine.\nStrategies: Types and concept for building strategies.\nExchanges: Loads exchanges instances, markets and pairlists, based on ccxt.\nPlotting: Output plots for ohlcv data, indicators, backtests, based on Makie.\nData: Loading and saving ohlcv data (and more), based Zarr.\nStats: Statistics about backtests, and live operations.\nProcessing: Data cleanup, normalization, resampling functions.\nWatchers: Services for data pipelines, from sources to storage.\nMisc: Ancillary stuff, like configuration, and some UI bits.\nAnalysis: The bulk of indicators evaluation, depends of a bunch of (heavy) julia libraries like CausalityTools and Indicators.","category":"page"},{"location":"#Infos","page":"Introduction","title":"Infos","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Troubleshooting\nDevdocs\nContacts","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"By learning the main types you get to know the building blocks to start composing your strategy for backtesting and/or live trading.","category":"page"},{"location":"types/#API","page":"Types","title":"API","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [Instruments, Instruments.Derivatives]\nOrder = [:type]","category":"page"},{"location":"types/#Instruments.Asset5","page":"Types","title":"Instruments.Asset5","text":"An Asset represents a parsed raw (usually ccxt) pair of base and quote currency.\n\nraw: The raw underlying string e.g. 'BTC/USDT'\nbc: base currency (Symbol)\nqc: quote currency (Symbol)\nfiat: if both the base and quote currencies match a known fiat symbol e.g. 'USDT/USDC'\nleveraged: if parsing matched a leveraged token e.g. 'ETH3L/USDT' or 'ETH3S/USDT'\nunleveraged_bc: a leveraged token with the mod removed, e.g. ETH3L => ETH\n\n> asset = a\"BTC/USDT\"\n> typeof(asset)\nAsset{:BTC, :USDT}\nend\n\n\n\n\n\n","category":"type"},{"location":"types/#Instruments.BaseCurrency","page":"Types","title":"Instruments.BaseCurrency","text":"A symbol checked to be a valid base currency.\n\n\n\n\n\n","category":"type"},{"location":"types/#Instruments.Cash","page":"Types","title":"Instruments.Cash","text":"A variable quantity of some currency.\n\n> ca = c\"USDT\"\n> typeof(ca)\n# Instruments.Cash{:USDT}\n\n\n\n\n\n","category":"type"},{"location":"types/#Instruments.QuoteCurrency","page":"Types","title":"Instruments.QuoteCurrency","text":"A symbol checked to be a valid quote currency.\n\n\n\n\n\n","category":"type"},{"location":"types/#Instruments.Derivatives.Derivative8","page":"Types","title":"Instruments.Derivatives.Derivative8","text":"Derivative parsed accordingly to regex.\n\nasset: The underlying asset.\nsc: settlement currency.\nid: identifier of the contract (the date).\nstrike: strike price.\nkind: Instruments.Derivatives.DerivativeKind\n\n\n\n\n\n","category":"type"},{"location":"types/#Instruments.Derivatives.DerivativeKind","page":"Types","title":"Instruments.Derivatives.DerivativeKind","text":"Differentiates between perpetuals and options.\n\n\n\n\n\n","category":"type"},{"location":"types/#Instruments.Derivatives.SettlementCurrency","page":"Types","title":"Instruments.Derivatives.SettlementCurrency","text":"A symbol parsed as settlement currency.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [Instruments, Instruments.Derivatives]\nOrder = [:function]","category":"page"},{"location":"types/#Instruments.deleverage_pair-Tuple{T} where T<:AbstractString","page":"Types","title":"Instruments.deleverage_pair","text":"Remove leveraged pair pre/suffixes from base currency.\n\n\n\n\n\n","category":"method"},{"location":"types/#Instruments.isfiatpair-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractString","page":"Types","title":"Instruments.isfiatpair","text":"Check if both base and quote are fiat currencies.\n\n\n\n\n\n","category":"method"},{"location":"types/#Instruments.islegeragedpair-Tuple{Any}","page":"Types","title":"Instruments.islegeragedpair","text":"Test if pair has leveraged naming.\n\n\n\n\n\n","category":"method"},{"location":"types/#Instruments.subzero!-Tuple{Instruments.Cash10, Any}","page":"Types","title":"Instruments.subzero!","text":"Never subtract below zero.\n\n\n\n\n\n","category":"method"},{"location":"types/#Instruments.Derivatives.is_settled-Tuple{Instruments.Derivatives.Derivative8}","page":"Types","title":"Instruments.Derivatives.is_settled","text":"Predicates according to OctoBot\n\n\n\n\n\n","category":"method"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [Instruments, Instruments.Derivatives]\nOrder = [:macro, :constant]","category":"page"},{"location":"types/#Instruments.@a_str-Tuple{Any}","page":"Types","title":"Instruments.@a_str","text":"Parses pair to an Asset type. ```julia\n\ntypeof(a\"BTC/USDT\")\n\nInstruments.Asset\n\n\n\n\n\n","category":"macro"},{"location":"types/#Instruments.@c_str","page":"Types","title":"Instruments.@c_str","text":"Macro to instantiate Cash statically.\n\nDon't put spaces between the id and the value.\n\n> ca = c\"USDT\"1000\nUSDT: 1000.0\n\n\n\n\n\n","category":"macro"},{"location":"types/#Instruments.@pusdt_str-Tuple{Any}","page":"Types","title":"Instruments.@pusdt_str","text":"Rewrites sym as a perpetual usdt symbol.\n\n> pusdt\"btc\"\nBTC/USDT:USDT\n\n\n\n\n\n","category":"macro"},{"location":"types/#Instruments.FULL_SYMBOL_GROUPS_REGEX","page":"Types","title":"Instruments.FULL_SYMBOL_GROUPS_REGEX","text":"From CCTX\n\n\n\n\n\n","category":"constant"},{"location":"types/#Instruments.fiatnames","page":"Types","title":"Instruments.fiatnames","text":"A list of fiat and fiat-like assets names.\n\n\n\n\n\n","category":"constant"},{"location":"types/#Instruments.Derivatives.@d_str-Tuple{Any}","page":"Types","title":"Instruments.Derivatives.@d_str","text":"Shortand for parsing derivatives:\n\n> drv = d\"BTC/USDT:USDT\"\n> typeof(drv)\n# Instruments.Derivatives.Derivative{Asset{:BTC, :USDT}}\n\n\n\n\n\n","category":"macro"}]
}
