var documenterSearchIndex = {"docs":
[{"location":"API/stats/#Stats","page":"Stats","title":"Stats","text":"","category":"section"},{"location":"API/stats/","page":"Stats","title":"Stats","text":"Modules = [Stats]","category":"page"},{"location":"API/stats/#Stats.multi-Tuple{Strategies.Strategy, Vararg{Symbol}}","page":"Stats","title":"Stats.multi","text":"Returns a dict of the calculated metrics see METRICS for what's available.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.resample_trades","page":"Stats","title":"Stats.resample_trades","text":"Aggregates all trades of a strategy in a single dataframe\n\nbyinstance: (trades_df, ai) -> nothing can modify the dataframe of a single instance before it is appended to the full df. style: :full or :minimal specifies what columns should be aggregated in the resampled df custom: similar to style but instead allows you to define custom aggregation rules (according to DataFrame) expand_dates: returns a contiguous dataframe from the first trade date to the last (inserting default ohlcv rows where no trades have happened.)\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.resample_trades-Tuple{Instances.AssetInstance15, Any}","page":"Stats","title":"Stats.resample_trades","text":"Resamples trades data from a smaller to a higher timeframe.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.trades_balance","page":"Stats","title":"Stats.trades_balance","text":"Plots the trade history for all the assets in a strategy.\n\nreturn_all[true]: similar to the function for single assets, plus:\n\ncum_quote: the balance of cash for each timestamp\ncum_value_balance: the balance of all held assets in quote currency for each timestamp.\n\nbyasset[false]: also return a column that tracks the value balance by asset for each timestamp normalize_timeframes:\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.trades_balance-Tuple{Instances.AssetInstance15}","page":"Stats","title":"Stats.trades_balance","text":"Replays the trade history of a single asset instance.\n\nreturn_all: if true returns a dataframe where:\n\nbase/quote_balance the volume generated by the trades that happened at that timestamp.\n:cum_total represents the total balance held for each timestamp.\n:cum_value_balance represents the value in quote currency of the asset for each timestamp.\n\nwarning: For single assets only\nIf your strategy trades multiple assets the profits returned by this function won't match the strategy actual holdings since calculation are done only w.r.t this single asset.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.tradesvolume!-Tuple{Misc.NoMargin, Any}","page":"Stats","title":"Stats.tradesvolume!","text":"Buys substract quote currency, while sells subtract base currency\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.tradesvolume!-Tuple{Misc.WithMargin, Any}","page":"Stats","title":"Stats.tradesvolume!","text":"Entries substract quote currency, Exits subtract base currency\n\n\n\n\n\n","category":"method"},{"location":"customizations/backtest/#HFT-backtesting","page":"Backtester","title":"HFT backtesting","text":"","category":"section"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"The pingpong backtester (SimMode) relies on OHLCV data to execute trades. ","category":"page"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"A few reasons why you might not want to backtest tick by tick:","category":"page"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"Bid/ask data is hard to find and very large in size, it is more resource expensive.\nConstructing order book data from trades history is guess work that introduces a lot of bias.\nBacktesting in such high details will likely overfit any strategy against a specific combination of market makers, more bias.\nBecause of the high data requirements and computational costs you might be able to only backtest a few days, not giving you enough confidence in the backtest itself since it can't run across regime changes.","category":"page"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"If you are still set in adding HFT backtesting there are two approaches: ","category":"page"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"The simpler one is to still use the OHLCV model, but construct the ohlcv from trades history building very short candles, like 1s. The backtester simply iterates over timesteps, by default using the strategy base timeframe. If you choose 1s as timeframe and feed it the correct candles it would be enough to run a backtest at the time resolution you require.\nThe harder approach is to create a new ExecMode, let's call it TickSimMode and reimplement the desired logic starting from the backtest! function. Practically most of the logic for orders creation can be reused, but functions like volumeat(ai, date) or openat,closeat, etc... are used to calculate fills and slippage, which query the current candle, and you would need to customize those to calc the correct price/volume of the trade from the tick data, (see for example limitorder_ifprice!).","category":"page"},{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"PingPong provides tools to optimize strategy parameters. Optimzations are managed through the OptSession type. Which is a structure that holds informations about the optimization parameters, configuration and previous runs. Optimization sessions can be periodically saved, and therefore can be reloaded at a later time to explore previous results or continue the optimization from where it left off.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"There are currently 3 different optimization methods: gridsearch, bboptimize boptimize!. Configuration is done by defining three ping! functions.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"ping!(::S, ::OptSetup): returns a named tuples with:\nctx: a Executors.Context which is the period of time used for backtesting\nparams: a named tuple of all the parameters to be optimizied. Values should be in the form of iterables.\nspace: only required for bboptimize, a named tuple where\nkind: is the type of space (from BlackBoxOptim package)\nprecision: If the space is :MixedPrecisionRectSearchSpace it is a vector where each element is the number of decimals to consider in parameters of type float.\nping!(::S, ::OptRun): called before a single backtest is run. Receives one combination of the parameters. Should apply the parameters to the strategy. No return values expected.\nping!(::S, ::OptScore)::Vector: for bboptimize and boptimize! it is the objective score that advances the optimization. In grid search it can be used to store additional metrics in the results dataframe. Within the Stats package there are metrics like sharpeorsortino` commonly used as optimization objectives.","category":"page"},{"location":"optimization/#Grid-search","page":"Optimization","title":"Grid search","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"This is the recommended approach, useful if the strategy has a small set of parameters (<5).","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"using Optimization\ngridsearch(s, repeats=1, save_freq=Minute(1), resume=false)","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Will perform an search from scratch, saving every minute. repeats controls the number of times a backtest is run using the same combination of parameters. When repeats > 1 we split the optimization Context into shorter ranges and restart the backtest on each one of these sub contexes. This allows to fuzz out scenarios of overfitting by averaging the results of different backtest \"restarts\".","category":"page"},{"location":"optimization/#Black-box-optimization","page":"Optimization","title":"Black box optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"The BlackBoxOptim offers multiple methods for searching, also also offers multi objective optimization. You can pass any arg supported by the upstream bboptimze function.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Optimization.bboptimize(s, repeats=3, MaxTime=240.0, Method=:borg_moea)","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"We exclude some optimization methods because they are slow or for some other quirks. Get the list of methods by calling bbomethods.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Optimization.bbomethods()\nOptimization.bbomethods(true) # multi obj methods","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"@doc bboptimize shows some common argument you might want to pass to the optimization function like MaxTime or MaxSteps. For the full list refer to the BlackBoxOptimi package.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"The BayesianOptimization package instead focus on gausiann processes and is provided as an extension of the Optimization package, (you need to install the packgage yourself). If you want to customize the optimization parameters you can define methods for your strategy over the functions gpmodel, modelopt and acquisition. Like bboptimize you can pass any upstream kwargs to boptimize!.","category":"page"},{"location":"optimization/#Multi-threading","page":"Optimization","title":"Multi threading","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Parallel execution is supported for the optimizations in different capacities. For grid search we allow parallel execution between different combinations, while repetitions are done sequentially. For black box optimization instead, repetitions are done in parallel, while the optimization run is done sequentially because the improvement of parallel execution during optimization is marginal, and because BlackBoxOptim current multi threading support is broken. Multi threading is only enabled if the strategy defines a global value like:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"const THREADSAFE = Ref(true)","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"warning: Thread safety\nMulti threading is not safe in general, avoid any use of python objects within your strategy or you will incur into crashes. Use locks or ConcurrentCollections for synchronization. You are responsible for the thread safety of your strategy.","category":"page"},{"location":"optimization/#Plotting-results","page":"Optimization","title":"Plotting results","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"After completing an optimization, the results can be plotted using the function Plotting.plot_results. The function accepts many arguments in order to customize which axes to plot (up to 3), how to customize coloring of plot elements (e.g. default cash column in a scatter plot go from red to green) and how to group results elements. It by default plot a scatter. Surfaces and contourf also work fine.","category":"page"},{"location":"exchanges/#Exchanges","page":"Exchanges","title":"Exchanges","text":"","category":"section"},{"location":"exchanges/#Exchange-Types","page":"Exchanges","title":"Exchange Types","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Basic exchange types, and global exchange vars.","category":"page"},{"location":"exchanges/#API","page":"Exchanges","title":"API","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [Exchanges.ExchangeTypes]\nPages = [\"ExchangeTypes.jl\"]","category":"page"},{"location":"exchanges/#Exchange-functions","page":"Exchanges","title":"Exchange functions","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [Exchanges]\nPages = [\"exchanges.jl\", \"pairlist.jl\", \"-data.jl\"]","category":"page"},{"location":"exchanges/#Data","page":"Exchanges","title":"Data","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Extensions for the top level Data module.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [PingPong.Exchanges]\nPages = [\"data.jl\"]","category":"page"},{"location":"exchanges/#Data.load_ohlcv-Tuple{AbstractString}","page":"Exchanges","title":"Data.load_ohlcv","text":"Loads all pairs given timeframe matching global exc and config.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.load_ohlcv-Tuple{Exchange, AbstractString}","page":"Exchanges","title":"Data.load_ohlcv","text":"Loads all pairs for given exc/timeframe matching global config and zi (ZarrInstance).\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.load_ohlcv-Tuple{Union{AbstractDict, AbstractArray}, AbstractString}","page":"Exchanges","title":"Data.load_ohlcv","text":"Load given pairs from global exc and ZarrInstance.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.load_ohlcv-Tuple{}","page":"Exchanges","title":"Data.load_ohlcv","text":"Load all pairs from exchange according to config quote currency and timeframe.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.save_ohlcv-Tuple{Any, Any, Any}","page":"Exchanges","title":"Data.save_ohlcv","text":"Updates pair data of the globally set exchange.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetching","page":"Exchanges","title":"Fetching","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Helper module for downloading data off exchanges.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [Fetch]","category":"page"},{"location":"exchanges/#Fetch.SINCE_MIN_PERIOD","page":"Exchanges","title":"Fetch.SINCE_MIN_PERIOD","text":"Used to slide the since param forward when retrying fetching (in case the requested timestamp is too old).\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Base.convert-Tuple{Type{Tuple{Vector{Dates.DateTime}, Vararg{Vector{Float64}, 5}}}, PythonCall.Py}","page":"Exchanges","title":"Base.convert","text":"This is the fastest (afaik) way to convert ccxt lists to dataframe friendly format.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_loop-Union{Tuple{F}, Tuple{Function, Exchange, Any}} where F<:AbstractFloat","page":"Exchanges","title":"Fetch._fetch_loop","text":"Calls the fetc_func iteratively until the full dates range has been downloaded. NOTE: The returned data won't be exactly the number of candles expected by e.g. length(DateRange(from, to))\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_ohlcv_from_to-Tuple{Exchange, Any, Any}","page":"Exchanges","title":"Fetch._fetch_ohlcv_from_to","text":"Ensure a to date is set, before fetching.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_with_delay-Tuple{Function, Any}","page":"Exchanges","title":"Fetch._fetch_with_delay","text":"Wraps a fetching function around error handling and backoff delay. fetch_func signature: (pair::String, since::Option{Float}, limit::Float) -> PyList The converter function has to tabulate the data such that the first column is the timestamp\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_ohlcv-Tuple{Exchange, AbstractString, Union{AbstractSet{T}, AbstractVector{T}, Tuple{Vararg{T}}} where T}","page":"Exchanges","title":"Fetch.fetch_ohlcv","text":"Fetch ohlcv data from exchange for a list of pairs.\n\nfrom, to: Can represent a date. A negative from number implies fetching the last N=from candles.\nupdate: If true, will check for cached data, and fetch only missing candles. (false)\nprogress: if true, show a progress bar. (true)\nreset: if true, will remove cached data before fetching. (false)\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_ohlcv-Tuple{Vector{Exchange}, Any}","page":"Exchanges","title":"Fetch.fetch_ohlcv","text":"Fetch ohlcv data for multiple exchanges on the same timeframe.\n\nIt accepts:\n\na mapping of exchange instances to pairlists.\na vector of symbols for which an exchange instance will be instantiated for each element,   and pairlist will be composed according to quote currency and min_volume from PingPong.config.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.find_since-Tuple{Exchange, Any}","page":"Exchanges","title":"Fetch.find_since","text":"Should return the oldest possible timestamp for a pair, or something close to it.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.funding_data-Tuple{Exchange, AbstractString, Vararg{Any}}","page":"Exchanges","title":"Fetch.funding_data","text":"Retrieves all funding data return by exchange for symbol, or a subset.\n\nfunding_data(exc, \"BTC/USDT:USDT\")\nfunding_data(exc, \"BTC/USDT:USDT\", :fundingRate, :markPrice)\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.funding_history-Tuple{Exchange, Vector}","page":"Exchanges","title":"Fetch.funding_history","text":"Fetch funding rate history from exchange for a list of Derivative pairs.\n\nfrom, to: specify date period to fetch candles for.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"API/misc/","page":"Misc","title":"Misc","text":"Modules = [PingPong.Misc]","category":"page"},{"location":"API/misc/#Misc.ATOL","page":"Misc","title":"Misc.ATOL","text":"The margin of error to use [2eps].\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.config","page":"Misc","title":"Misc.config","text":"Global configuration instance.\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.fetch_limits","page":"Misc","title":"Misc.fetch_limits","text":"Exchange ohlcv candles limits.\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.futures_exchange","page":"Misc","title":"Misc.futures_exchange","text":"Some exchanges are split into different classes in ccxt.\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.results","page":"Misc","title":"Misc.results","text":"Holds recently evaluated statements.\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.Config","page":"Misc","title":"Misc.Config","text":"The config main structure:\n\npath: File path that loaded this config.\nmode: Execution mode (Sim, Paper, Live)\nexchange: A symbol to instantiate an exchange (a raw ExchangeID symbol)\nqc: The quote currency for the strategy cash.\nmargin: configures the margin mode of the strategy (NoMargin, Isolated or Cross)\nleverage: The default leverage that should be used when opening position with margin mode.\nmin_vol: A minimum acceptable volume, e.g. for filtering markets.\ninitial_cash: Starting cash, used when instantiating a strategy.\nmin_size: Default order size.\nmin_timeframe: The default (shortest) timeframe of the candles.\ntimeframes: Vector of sorted timeframes that the strategy uses (for loading data).\nwindow: (deprecated) The default number of candles (OHLCV).\nattrs: Generic metadata container.\nsources: mapping of modules symbols name to (.jl) file paths\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.DFT","page":"Misc","title":"Misc.DFT","text":"The floating point number type to use.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Base.copy-Tuple{Misc.Config}","page":"Misc","title":"Base.copy","text":"Shallow copies the config, and top level containers fields timeframes and attrs.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc._instantiate_workers-Tuple{Any}","page":"Misc","title":"Misc._instantiate_workers","text":"Instantiate new workers if the current number mismatches the requested one.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.after-Tuple{AbstractVector, Any}","page":"Misc","title":"Misc.after","text":"Returns a view of the sorted vector v, indexed using rangeafter.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.before-Tuple{AbstractVector, Any}","page":"Misc","title":"Misc.before","text":"Returns a view of the sorted vector v, indexed using rangebefore.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.between-Tuple{AbstractVector, Any, Any}","page":"Misc","title":"Misc.between","text":"Returns a view of the sorted vector v, indexed using rangebetween.\n\njulia> between([1, 2, 3, 3, 3], 3, 3; strict=true)\n0-element view(::Vector{Int64}, 6:5) with eltype Int64\njulia> between([1, 2, 3, 3, 3], 1, 3; strict=true)\n1-element view(::Vector{Int64}, 2:2) with eltype Int64:\n 2\njulia> between([1, 2, 3, 3, 3], 2, 3; strict=false)\n2-element view(::Vector{Int64}, 3:4) with eltype Int64:\n 3\n 3\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.config!-Tuple{Union{String, Symbol}}","page":"Misc","title":"Misc.config!","text":"Parses the toml file and populates the config cfg (defaults to global config).\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.config_path-Tuple{}","page":"Misc","title":"Misc.config_path","text":"The config path (TOML), relative to the current project directory.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.rangeafter-Tuple{AbstractVector, Any}","page":"Misc","title":"Misc.rangeafter","text":"Returns the range index of sorted vector v for all the values after d. when strict is false, the range will start after the first occurence of d.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.rangebefore-Tuple{AbstractVector, Any}","page":"Misc","title":"Misc.rangebefore","text":"Returns the range index of sorted vector v for all the values before d. when strict is false, the range will start before the last occurence of d.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.rangebetween-Tuple{AbstractVector, Any, Any}","page":"Misc","title":"Misc.rangebetween","text":"Returns the range index of sorted vector v for all the values before d. Argument strict behaves same as rangeafter and rangebefore.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.reset!-Tuple{Misc.Config}","page":"Misc","title":"Misc.reset!","text":"Reset config to default values.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.toprecision-Tuple{AbstractFloat, Integer}","page":"Misc","title":"Misc.toprecision","text":"When precision is a Integer it represents the number of decimals.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.toprecision-Tuple{Union{AbstractFloat, Integer}, AbstractFloat}","page":"Misc","title":"Misc.toprecision","text":"When precision is a float it represents the pip.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.@as_dfdict","page":"Misc","title":"Misc.@as_dfdict","text":"Binds a mrkts variable to a Dict{String, DataFrame} where the keys are the pairs names and the data is the OHLCV data of the pair.\n\n\n\n\n\n","category":"macro"},{"location":"API/misc/#Misc.@lev!-Tuple{}","page":"Misc","title":"Misc.@lev!","text":"Toggle config leverage flag\n\n\n\n\n\n","category":"macro"},{"location":"API/misc/#Misc.@margin!-Tuple{}","page":"Misc","title":"Misc.@margin!","text":"Toggle config margin flag.\n\n\n\n\n\n","category":"macro"},{"location":"watchers/watchers/#Watchers","page":"Interface","title":"Watchers","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"A Watcher type is an interface over a data feed. There are implementations for some 3d party apis, and exchange OHLCV data construction and order book.","category":"page"},{"location":"watchers/watchers/#User-interface","page":"Interface","title":"User interface","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"To instantiate a watcher call its related function for example ccxt_ohlcv_watcher to instantiate a watcher that tracks trades data from an exchange and builds OHLCV candles for the specified timeframe. On a watcher instance these function are currently available:","category":"page"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"get: What you mostly use watchers for. Get the underlying data monitored by the watcher, usually in a processed state (like a DataFrame), it defaults to the watcher buffer (which should keep data in a raw state).\nlength: Length of the underlying buffer.\nlast: Last raw value of the underlying buffer.\nclose: Stops the watcher and flushes the buffer.\nisstale: Should evaluate if the watcher is in a degraded state, e.g. when it can't fetch new data.\nfetch!: A watcher runs queries on specified interval, so you should only use fetch! when you want to be sure that the watcher has the latest data.\nflush!: like fetch! the watcher already flushes at predetermined intervals, use this only to ensure flushing in case of shutdown. The watcher does call flush on destruction through its finalizer, but it does so asynchronously and doesn't ensure the success of the flush operation.\ndelete!: deletes the watcher data from the storage backend used by flush! (and empties the buffer).\ndeleteat!: deletes the watcher data within a date range (and empties the buffer).\npush!: add an element to the elements the watcher subscribes to (if any).\npop!: opposite of push!.\nstop: Stops the watcher.\nstart: Restarts the watcher.","category":"page"},{"location":"watchers/watchers/#Imlementation-interface","page":"Interface","title":"Imlementation interface","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"To implement a custom watcher you have to define the functions such that dispatch happens through the watcher name interpreted as a value Val{Symbol(my_watcher_name)}. So a function needs to have a signature like _fetch!(w::Watcher, ::Val{some_symbol}).","category":"page"},{"location":"watchers/watchers/#Required","page":"Interface","title":"Required","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"_fetch! whatever fetches the data, like an http request.\n_get returns the post processed data, like a DataFrame.","category":"page"},{"location":"watchers/watchers/#Optional","page":"Interface","title":"Optional","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"_init! to perform initialization routines.\n_load! to pre-fill the watcher buffer on construction, it is only called once, runs after _init!.\n_flush! to save the watcher buffer somewhere on periodic intervals and on watcher destruction.\n_process! to update the view of the raw data, which is what the get function should return.\n_delete! to delete all the storage data of the watcher.\n_deleteat! to delete the storage data of the watcher within a date range (from, to).\n_push! watchers might manage a list of things to track (like Asset symbols).\n_pop! inverse of _push!.\n_start Executed before starting the timer.\n_stop Executed after stopping the timer.","category":"page"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"Look in the Watchers and WatchersImpls modules for helper functions:","category":"page"},{"location":"watchers/watchers/#API","page":"Interface","title":"API","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"Modules = [Watchers, Watchers.WatchersImpls]","category":"page"},{"location":"data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"The main backend currently is Zarr. Zarr is similar to feather or parquet in that it optimizes to columnar data, or in general arrays. However it is simpler, and allows to pick different encoding schemes, and supports compression by default. More over the zarr interface can be backed by different storage layers, that can also be over the network. Compared to no/sql databases columnar storage has the drawback of having to read chunks for queries, but we are almost never are interested in scalar values, we always query a time-series of some sort, so the latency loss is a non issue.","category":"page"},{"location":"data/#Scraping","page":"Data","title":"Scraping","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"There are different ways to collect data:","category":"page"},{"location":"data/#Using-the-Scrapers-module","page":"Data","title":"Using the Scrapers module","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Currently there is support for binance and bybit archives.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using Scrapers: Scrapers as scr, BinanceData as bn\n## Download klines for ETH\nbn.binancedownload(\"eth\", market=:data, freq=:monthly, kind=:klines)\n## load them\nbn.binanceload(\"eth\", market=:data, freq=:monthly, kind=:klines)\n## Default market parameter is `:um` (usdm futures)\n\n# show all symbols that can be downloaded\nbn.binancesyms(market=:data)\n# load/download also accept `quote_currency` to filter by (default `usdt`)\nscr.selectsyms([\"eth\"], bn.binancesyms(market=:data), quote_currency=\"usdc\")","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"warning: Downloads are cached\ndownloading the same pair path again will only downloads newer archives if data gets corrupted pass reset=true to redownload it again. ","category":"page"},{"location":"data/#Using-the-Fetch-module","page":"Data","title":"Using the Fetch module","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"The Fetch module downloads data directly from the exchange using ccxt.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using TimeTicks\nusing Exchanges\nusing Fetch: Fetch as fe\n\nexc = getexchange!(:kucoin)\ntimeframe = tf\"1m\"\npairs = (\"BTC/USDT\", \"ETH/USDT\")\n# Will fetch the last 1000 candles, `to` can also be passed to download a specific range\nfe.fetch_candles(exc, timeframe, pairs; from=-1000)","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Fetching directly from exchanges is not recommended for smaller timeframes since they are heavily rate limited. Archives are better.","category":"page"},{"location":"data/#Using-Watchers","page":"Data","title":"Using Watchers","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"With the Watchers module you can track live data from exchanges or other data sources and store it locally.  Implemented are watchers that track OHLCV:","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using Exchanges\nusing PingPong.Watchers: Watchers as wc, WatchersImpls as wi\nexc = getexchange!(:kucoin)\n\nw = wi.ccxt_ohlcv_tickers_watcher(exc;)\nwc.start!(w)","category":"page"},{"location":"data/","page":"Data","title":"Data","text":">>> w\n17-element Watchers.Watcher20{Dict{String, NamedTup...Nothing, Float64}, Vararg{Float64, 7}}}}}\nName: ccxt_ohlcv_ticker\nIntervals: 5 seconds(TO), 5 seconds(FE), 6 minutes(FL)\nFetched: 2023-03-07T12:06:18.690 busy: true\nFlushed: 2023-03-07T12:04:31.472\nActive: true\nAttemps: 0","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"As a convention the view property of a watcher shows the processed data. In this case the candles processed by the ohlcv_ticker_watcher will be stored in a dict.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":">>> w.view\nDict{String, DataFrames.DataFrame} with 220 entries:\n  \"HOOK/USDT\"          => 5×6 DataFrame…\n  \"ETH/USD:USDC\"       => 5×6 DataFrame…\n  \"PEOPLE/USDT:USDT\"   => 5×6 DataFrame…","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"There is another OHLCV watcher based on trades, that tracks only one pair at a time.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"w = wi.ccxt_ohlcv_watcher(exc, \"BTC/USDT:USDT\"; timeframe=tf\"1m\")\nw.view\n956×6 DataFrame\n Row │ timestamp            open     high     low      close    volume  \n     │ DateTime             Float64  Float64  Float64  Float64  Float64 \n─────┼──────────────────────────────────────────────────────────────────\n...","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Other implemented watchers are the orderbook watcher, and watchers that parse data feeds from 3rd party apis.","category":"page"},{"location":"engine/engine_notes/#Backtesting-overview","page":"Backtesting overview","title":"Backtesting overview","text":"","category":"section"},{"location":"engine/engine_notes/#Goals","page":"Backtesting overview","title":"Goals","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"The backtest should be able to be executed given a custom start and end date.\nThe strategy has to have access to the OHLCV and all past trade history.\nIt must be able to run during live trading.","category":"page"},{"location":"engine/engine_notes/#Main-loop","page":"Backtesting overview","title":"Main loop","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"for each timestamp:\nwhile true:\nprocess(strategy, timestamp, context)","category":"page"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"The loop is just a timestamp feeder!, and the strategy holds all the state.","category":"page"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"Because we use the TimeFrames abstraction, the step can be arbitrary, the strategy will just index into ohlcv data according to the last candle compatible with the given timestamp. This is a performance trade-off, we prefer to always index with dates, and never with integers, because it reduces the assumptions to the row data must match its timestamp (its not corrupted!) compared to spurious bugs that might arise by integer indexing.\nThe simulation is adversarial to the strategy, it is the job of the simulation to decide how much loss a trade has incurred.","category":"page"},{"location":"engine/engine_notes/#Strategy-General-Considerations","page":"Backtesting overview","title":"Strategy General Considerations","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"The strategy must account for a  tie breaker to choose which trades to perform on the same candle since we don't know which pair we observed first. In general this is a good use case for MC.","category":"page"},{"location":"engine/engine_notes/#What-does-executing-an-order-mean?","page":"Backtesting overview","title":"What does executing an order mean?","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"When the engine executes an order, it does the following for every order:","category":"page"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"Decide if order should be honored or fail\nPerform simulations, like spread, slippage, market impact.\nSignal to the strategy about failed (canceled) orders.","category":"page"},{"location":"watchers/apis/coingecko/#CoinGecko","page":"CoinGecko","title":"CoinGecko","text":"","category":"section"},{"location":"watchers/apis/coingecko/#API","page":"CoinGecko","title":"API","text":"","category":"section"},{"location":"watchers/apis/coingecko/","page":"CoinGecko","title":"CoinGecko","text":"Modules = [Watchers.CoinGecko]","category":"page"},{"location":"engine/backtesting/#Running-a-backtest","page":"Backtesting","title":"Running a backtest","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"To run a backtest you construct a strategy and then call backtest! on it.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"The strategy loads by default a config file located in PingPong.jl/user/config.toml\nThe config defines the strategy file under include_file key in the [Example] section","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"[Example]\ninclude_file = \"strategies/Example.jl\"","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"The strategy file Example.jl defines the Example module","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"module Example\nping!(s::Strategy, ts, ctx) = pong!(...)\nend","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"info: Backtesting\nIt is based on some assumptions","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"using Engine.Strategies\nusing Engine.Executors: SimMode as bt\ns = strategy(:Example)\n# Load data in the strategy universe (you need to already have it)\nfill!(s) # or stub!(s.universe, datadict)\n# backtest the strategy within the period available from the loaded data.\nbt.backtest!(s)\n# Lets see how we fared:\ndisplay(s)\n## output\nName: Example\nConfig: 10.0(USDT)(Base Size), 100.0(USDT)(Initial Cash)\nUniverse: 3 instances, 1 exchanges\nHoldings: assets(trades): 2(977), min BTC: 23.13(USDT), max XMR: 79.611(USDT)\nPending buys: 3\nPending sells: 0\nUSDT: 32.593 (Cash)\nUSDT: 156.455 (Total)","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Our backtest says that our strategy...","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Operated on 3 assets (instances)\nExecuted 977 trades\nStarting from 100 USDT it finished with 32 USDT in cash, and 156 USDT worth of assets\nThe assets at the end with the minimum value was BTC and the one with the maximum value was XMR.\nAt the end there were 3 left open buy orders and no open sell orders.","category":"page"},{"location":"engine/backtesting/#Orders","page":"Backtesting","title":"Orders","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"To make a limit order within your strategy you call pong! just like any call to the executor. The arguments:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"trade = pong!(s, GTCOrder{Buy}, ai; price, amount, date=ts)","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Where s is your Strategy{Sim, ...} instance, ai is the AssetInstance which the order refers to (it should be one present in your s.universe) amount is the quantity in base currency and date should be the one fed to the ping! function, which during backtesting would be the current timestamp being evaluated, and during live a recent timestamp. If you look at the example strategy ts is current and ats available. The available timestamp ats is the one that matches the last candle that doesn't give you forward knowledge. The date given to the order call (pong!) must be always the current timestamp.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"A limit order call might return a trade if the order was queued correctly. If the trade hasn't completed the order, the order is queued in s.buy/sellorders[ai]. If isnothing(trade) is trueit means the order failed, and was not scheduled, this can happen if the cost of the trade did not meet the asset limits, or there wasn't enough commitable cash. If instead ismissing(trade) is true it means that the order was scheduled, but that no trade has yet been performed. In backtesting this happen if the price of the order is too low(buy) or too high(sell) for the current candle high/low prices.","category":"page"},{"location":"engine/backtesting/#Limit-order-types","page":"Backtesting","title":"Limit order types","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Other than GTC orders there are also IOC and FOK orders:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"GTC (good till cancelled)\nIOC (immediate or cancel)\nFOK (fill or kill) All three are subtypes of a limit order, <: LimitOrder. Create them calling pong! like above:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"trade = pong!(s, IOCOrder{Buy}, ai; price, amount, date=ts)\ntrade = pong!(s, FOKOrder{Sell}, ai; price, amount, date=ts)","category":"page"},{"location":"engine/backtesting/#Market-order-types","page":"Backtesting","title":"Market order types","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Market order types are of:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"MarketOrder\nLiquidationOrder\nForcedOrder","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"They all behave in the same way, apart from the liquidation type which price might differ from the candle price on execution. A forced order is a market order triggered automatically when manually closing a position, for example when calling.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"pong!(s, ai, Long(), now(), PositionClose())","category":"page"},{"location":"engine/backtesting/#Market-Orders","page":"Backtesting","title":"Market Orders","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Despite the fact that ccxt allows setting timeInForce also for market orders, because in general exchanges allow to do so, there isn't definitive information about how a market order is handled in these cases, remember that we deal with crypto so some context like open and close times days is lost. We can guess that it only matters when the orderbook doesn't have enough liquidity, otherwise they are always immediate and fully filled orders. For this reason we always consider market orders as FOK orders, and they will always have timeInForce set to FOK when executed live (through ccxt) to match the backtester.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"warning: Market orders can be surprising\nMarket orders always go through in the backtest. If the candle has no volume the order incurs in heavy slippage, and the execution price of the trades can exceed the candle high/low price.","category":"page"},{"location":"engine/backtesting/#Checks","page":"Backtesting","title":"Checks","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Before creating an order, some checks run to sanitize the values. If for example the amount is too small, the order picks the minimum amount instead. If there isn't enough cash after the amount adjumested, the order will fail. See the ccxt docs for precision and limits.","category":"page"},{"location":"engine/backtesting/#Fees","page":"Backtesting","title":"Fees","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"The fees come from the AssetInstance fees property, which itself comes from parsing the ccxt data about that particular symbol. Every trade accounts for such fees.","category":"page"},{"location":"engine/backtesting/#Slippage","page":"Backtesting","title":"Slippage","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Slippage is accounted for within the trade execution.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"For limit orders there can only be positive slippage, when an order is created and the price is in your favor, the actual price of execution becomes slightly lower (for buy orders) or higher (for sell orders). The slippage formula takes into account volatility (high / low) and fill ratio (amount / volume). The higher the volume the order takes from the candle, the lower the positive slippage will be, whereas the higher the volatility, the higher the positive slippage will be. Positive slippage is only added for candles that go against the order side, which means that it will be only added on red candles for buys, and green candles for sells.\nFor market orders there can only be negative slippage. There is a minimum slippage always added (which by default corresponds to the difference between open and close (there are other formulas, check the api ref) on top of which additional skew is added based on volume and volatility.","category":"page"},{"location":"engine/backtesting/#Backtesting-performance","page":"Backtesting","title":"Backtesting performance","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"A local benchmark shows that the :Example strategy which:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"uses FOK orders\nruns over 3 assets\ntrades in spot markets\nuses its simple logic which can you can read in the strategy code to execute orders","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Currently takes around ~8 seconds to loop over ~1.3M * 3 (assets) ~= 3.9M candles performing ~6000 trades on a single x86 core.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"It is important to highlight that the kind of orders performed and the amount of trades executed can affect the runtime considerably (ignoring other obvious factors like additional strategy logic or number of assets). So beware when someone states that a backtester can run X rows in Y time without providing additional details. Moreover our order creation logic always checks that order inputs are within the boundsaries of exchanges limits, and of course there is slippage an probability calculations too that allow the backtester to be \"MC simmable\".","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"It is inevitable that backtesting a strategy with margin will be slower since we have to account for all the calculations required like positions states and liquidation triggers.","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"The bot uses a configuration file, located at user/config.toml by default. Currently it only stores:","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"Minor exchange configurations. The ExchangeID symbol is the key that references the exchange config section.\nStrategies. The strategy module name is the section key.\ninclude_file: The entry file of the strategy\nmargin: margin mode to instantiate the strategy with.","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"You shouldn't expect to have to put too many options in the config, as the majority should be specified as constants in the strategy module itself. This avoids unexpected behaviour where a mix of config options and strategy options override each other.","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"Exchange api keys are stored in separate files with naming \\${ExchangeID}[_sandbox].json. Api keys for sandbox endpoints are suffixed with _sandbox. Exchanges are always instantiated in sandbox mode by default and indeed if the exchange doesn't have a sandbox you need to pass sandbox=false to the exchange creation function, like getexchange!(:okx, sandbox=false).","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"Third party apps in the Watchers module use the secrets.toml file.","category":"page"},{"location":"API/instruments/#Instruments","page":"Instruments","title":"Instruments","text":"","category":"section"},{"location":"API/instruments/","page":"Instruments","title":"Instruments","text":"Modules = [Instruments, Instruments.Derivatives]\nOrder = [:type]","category":"page"},{"location":"API/instruments/#Instruments.Asset","page":"Instruments","title":"Instruments.Asset","text":"An Asset represents a parsed raw (usually ccxt) pair of base and quote currency.\n\nraw: The raw underlying string e.g. 'BTC/USDT'\nbc: base currency (Symbol)\nqc: quote currency (Symbol)\nfiat: if both the base and quote currencies match a known fiat symbol e.g. 'USDT/USDC'\nleveraged: if parsing matched a leveraged token e.g. 'ETH3L/USDT' or 'ETH3S/USDT'\nunleveraged_bc: a leveraged token with the mod removed, e.g. ETH3L => ETH\n\n> asset = a\"BTC/USDT\"\n> typeof(asset)\nAsset{:BTC, :USDT}\nend\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.BaseCurrency","page":"Instruments","title":"Instruments.BaseCurrency","text":"A symbol checked to be a valid base currency.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.Cash","page":"Instruments","title":"Instruments.Cash","text":"A variable quantity of some currency.\n\n> ca = c\"USDT\"\n> typeof(ca)\n# Instruments.Cash{:USDT}\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.QuoteCurrency","page":"Instruments","title":"Instruments.QuoteCurrency","text":"A symbol checked to be a valid quote currency.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.Derivatives.Derivative8","page":"Instruments","title":"Instruments.Derivatives.Derivative8","text":"Derivative parsed accordingly to regex.\n\nasset: The underlying asset.\nsc: settlement currency.\nid: identifier of the contract (the date).\nstrike: strike price.\nkind: Instruments.Derivatives.DerivativeKind\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.Derivatives.DerivativeKind","page":"Instruments","title":"Instruments.Derivatives.DerivativeKind","text":"Differentiates between perpetuals and options.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.Derivatives.SettlementCurrency","page":"Instruments","title":"Instruments.Derivatives.SettlementCurrency","text":"A symbol parsed as settlement currency.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/","page":"Instruments","title":"Instruments","text":"Modules = [Instruments, Instruments.Derivatives]\nOrder = [:function]","category":"page"},{"location":"API/instruments/#Instruments.addzero!-Tuple{Cash, Any, Vararg{Any}}","page":"Instruments","title":"Instruments.addzero!","text":"Add v to cash, approximating to zero if cash is a small value.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.deleverage_pair-Tuple{T} where T<:AbstractString","page":"Instruments","title":"Instruments.deleverage_pair","text":"Remove leveraged pair pre/suffixes from base currency.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.isfiatpair-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractString","page":"Instruments","title":"Instruments.isfiatpair","text":"Check if both base and quote are fiat currencies.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.isleveragedpair-Tuple{Any}","page":"Instruments","title":"Instruments.isleveragedpair","text":"Test if pair has leveraged naming.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.spotpair-Tuple{AbstractString}","page":"Instruments","title":"Instruments.spotpair","text":"Strips the settlement currency from a symbol.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.subzero!-Tuple{Instruments.AbstractCash, Any, Vararg{Any}}","page":"Instruments","title":"Instruments.subzero!","text":"Sub v to cash, approximating to zero if cash is a small value.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.Derivatives.is_settled-Tuple{Instruments.Derivatives.Derivative8}","page":"Instruments","title":"Instruments.Derivatives.is_settled","text":"Predicates according to OctoBot\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/","page":"Instruments","title":"Instruments","text":"Modules = [Instruments, Instruments.Derivatives]\nOrder = [:macro, :constant]","category":"page"},{"location":"API/instruments/#Instruments.@a_str-Tuple{Any}","page":"Instruments","title":"Instruments.@a_str","text":"Parses pair to an Asset type. ```julia\n\ntypeof(a\"BTC/USDT\")\n\nInstruments.Asset\n\n\n\n\n\n","category":"macro"},{"location":"API/instruments/#Instruments.@c_str","page":"Instruments","title":"Instruments.@c_str","text":"Macro to instantiate Cash statically.\n\nDon't put spaces between the id and the value.\n\n> ca = c\"USDT\"1000\nUSDT: 1000.0\n\n\n\n\n\n","category":"macro"},{"location":"API/instruments/#Instruments.@importcash!-Tuple{}","page":"Instruments","title":"Instruments.@importcash!","text":"Cash should not be edited by a strategy, therefore functions that mutate its value should be explicitly imported.\n\n\n\n\n\n","category":"macro"},{"location":"API/instruments/#Instruments.@pusdt_str-Tuple{Any}","page":"Instruments","title":"Instruments.@pusdt_str","text":"Rewrites sym as a perpetual usdt symbol.\n\n> pusdt\"btc\"\nBTC/USDT:USDT\n\n\n\n\n\n","category":"macro"},{"location":"API/instruments/#Instruments.FULL_SYMBOL_GROUPS_REGEX","page":"Instruments","title":"Instruments.FULL_SYMBOL_GROUPS_REGEX","text":"From CCTX\n\n\n\n\n\n","category":"constant"},{"location":"API/instruments/#Instruments.fiatnames","page":"Instruments","title":"Instruments.fiatnames","text":"A list of fiat and fiat-like assets names.\n\n\n\n\n\n","category":"constant"},{"location":"API/instruments/#Instruments.Derivatives.@d_str-Tuple{Any}","page":"Instruments","title":"Instruments.Derivatives.@d_str","text":"Shortand for parsing derivatives:\n\n> drv = d\"BTC/USDT:USDT\"\n> typeof(drv)\n# Instruments.Derivatives.Derivative{Asset{:BTC, :USDT}}\n\n\n\n\n\n","category":"macro"},{"location":"API/optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"API/optimization/","page":"Optimization","title":"Optimization","text":"Modules = [Optimization]","category":"page"},{"location":"API/optimization/#Optimization.OptSession18","page":"Optimization","title":"Optimization.OptSession18","text":"An optimization session stores all the evaluated parameters combinations.\n\n\n\n\n\n","category":"type"},{"location":"API/optimization/#BlackBoxOptim.bboptimize-Tuple{Strategies.SimStrategy}","page":"Optimization","title":"BlackBoxOptim.bboptimize","text":"Optimize parameters using the BlackBoxOptim package.\n\nrepeats: how many times to run the backtest for each step\nseed: random seed\nkwargs: The arguments to pass to the underlying BBO function. See the docs for the BlackBoxOptim package. Here are some most common parameters:\nMaxTime: max evaluation time for the optimization\nMaxFuncEvals: max number of function (backtest) evaluation\nTraceMode: (:silent, :compact, :verbose) controls the logging\nMaxSteps, MaxStepsWithoutProgress\n\nFrom within your strategy define four ping! functions:\n\nping!(::Strategy, ::OptSetup): for the period of time to evaluate and the parameters space for the optimization..\nping!(::Strategy, params, ::OptRun): called before running the backtest, should apply the parameters to the strategy\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization._multi_opt_func-NTuple{4, Any}","page":"Optimization","title":"Optimization._multi_opt_func","text":"Multi(threaded) optimization function.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization._single_opt_func-Tuple{Any, Any, Any, Vararg{Any}}","page":"Optimization","title":"Optimization._single_opt_func","text":"Single(threaded) optimization function.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.bbomethods","page":"Optimization","title":"Optimization.bbomethods","text":"Get a filtered list of methods supported by BBO (single or multi).\n\n\n\n\n\n","category":"function"},{"location":"API/optimization/#Optimization.define_median_func-Tuple{Any}","page":"Optimization","title":"Optimization.define_median_func","text":"The median in multi(objective) mode has to be applied over all the (repeated) iterations.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.delete_sessions!-Tuple{String}","page":"Optimization","title":"Optimization.delete_sessions!","text":"Clear all optimization session of a strategy. keep_by: will not delete sessions that match this attributes (Dict{String, Any}).     - ctx: the Context of the optimization session     - params: the params (NamedTuple) of the optimization session     - attrs: the config (NamedTuple) of the optimization session\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.gridsearch-Tuple{Strategies.SimStrategy}","page":"Optimization","title":"Optimization.gridsearch","text":"Backtests the strategy across combination of parameters. s: The strategy. seed: random seed set before each backtest run. repeats: the amount of repetitions for each combination. save_freq: how frequently (Period) to save results, when nothing (default) saving is skipped. logging: enabled logging doshuffle: shuffle parameters combinations before iterations (random search)\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.load_session","page":"Optimization","title":"Optimization.load_session","text":"Load an optimization session from storage, name:\n\nname: strategy name\nstart/stop: start and stop date of the backtesting context\nparams_k: the first letter of every param (first.(string.(keys(sess.params))))\ncode: hash of params and attrs truncated to 4 chars.\n\nOnly the strategy name is required, rest is optional.\n\n\n\n\n\n","category":"function"},{"location":"API/optimization/#Optimization.objectives-Tuple{Any}","page":"Optimization","title":"Optimization.objectives","text":"Returns the number of objectives and their type.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.optsessions-Tuple{String}","page":"Optimization","title":"Optimization.optsessions","text":"Returns the zarrays storing all the optimization session over the specified zarrinstance.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.progsearch-Tuple{Any}","page":"Optimization","title":"Optimization.progsearch","text":"A progressive search performs multiple grid searches with only 1 repetition per parameters combination. After each search is completed, the results are filtered according to custom rules. The parameters from the results that match the filtering will be backtested again with a different offset which modifies the backtesting period. rounds: how many iterations (of grid searches) to perform sess: If a Ref{<:OptSession} is provided, search will resume from the session previous results halve: At each iteration\n\nAdditional kwargs are forwarded to the grid search.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.remove_incomplete!-Tuple{Optimization.OptSession18}","page":"Optimization","title":"Optimization.remove_incomplete!","text":"Remove results that don't have all the repeated evalutaion.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.result_params","page":"Optimization","title":"Optimization.result_params","text":"Fetch the named tuple of a single parameters combination.\n\n\n\n\n\n","category":"function"},{"location":"API/optimization/#Optimization.save_session-Tuple{Optimization.OptSession18}","page":"Optimization","title":"Optimization.save_session","text":"Save the optimization session over the provided zarr instance.\n\nsess: the OptSession from: save the optimization results starting from the specified index (when saving progressively) to: save the optimization results up to the specified index (when saving progressively)\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.slidesearch-Tuple{Strategies.Strategy}","page":"Optimization","title":"Optimization.slidesearch","text":"Backtests by sliding over the backtesting period, by the smallest timeframe (the strategy timeframe). Until a full range of timeframes is reached between the strategy timeframe and backtesting context timeframe. multiplier: the steps count (total stepps will be multiplier * context_timeframe / s.timeframe )\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Strategies.ping!-Tuple{Strategies.Strategy, Any, Executors.OptRun}","page":"Optimization","title":"Strategies.ping!","text":"This ping function should apply the parameters to the strategy, called before the backtest is performed. \n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Strategies.ping!-Tuple{Strategies.Strategy, Executors.OptSetup}","page":"Optimization","title":"Strategies.ping!","text":"Has to return a Optimizations.ContextSpace named tuple where ctx (Executors.Context) is the time period to backtest and the space is either an already constructed subtype of BlackBoxOptim.SearchSpace or a tuple (Symbol, args...) for a search space pre-defined within the BBO package.\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Engine","page":"Executors","title":"Engine","text":"","category":"section"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Within the PingPong \"model\" we use ping! and pong! functions to communicate between strategies and executors. The executor \"pings\" the strategy, impliying that the strategy should do, or return something. The strategy instead \"pongs\" the executor, expecting it to do, or return something.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"The user of the bot, generally, only writes ping! functions within their strategies. In the case the user requires custom behaviour that is not implemented by the framework, they might be required to write pong! functions.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Other trading bots offer a set of methods that the user can implement for tuning purposes, usually tied to the super class of the strategy.  Within PingPong instead, our convention is to only deal with ping! and pong! functions, such that you know that whenever a pong! call is done from the strategy, that is a point of possible divergence between simulation and live execution.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"In fact, ping and pong functions are implemented such that they dispatch differently according to the execution mode of the strategy.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"There are 3 execution modes: ","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Sim: what the backtester uses to run the simulations\nPaper: the dry run mode, that runs the bot like it would in live, working with live data feeds and simulating order execution with live prices.\nLive: like Paper but with order execution being actually forwarded to CCXT.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Therefore if the strategy is instantiated in Sim mode, calling pong!(s, ...), where s is the strategy object of type Strategy{Sim, S, E, M, C}, the pong! function will dispatch to the Sim execution method. S and E are the other two parameters which a strategy type requires for concretization.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"S<:Symbol: the symbol that matches the module name of the strategy, like :Example\nE<:ExchangeID: The symbol already checked to match a valid CCXT exchange, which will be the exchange that the strategy will operate on.\nM<:MarginMode: The margin mode of the strategy, either NoMargin, IsolatedMargin or CrossMargin. Node that the margin mode also has a type parameter to specify if hedged positions (having long and short on the same asset at the same time) are allowed. Isolated and Cross are short hands for IsolatedMargin{NotHedged} and CrossMargin{NotHedged}.\nC: C is the symbol of the CurrencyCash that represents the balance of the strategy, e.g. :USDT.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"To realize the pong! dispatch convention, you can expect the first argument of every pong function to be the strategy object itself, while ping function might have either the strategy object or the type of the strategy as first argument (Type{Strategy{...}}).","category":"page"},{"location":"contacts/#Github","page":"Contacts","title":"Github","text":"","category":"section"},{"location":"contacts/","page":"Contacts","title":"Contacts","text":"Submit an issue","category":"page"},{"location":"contacts/#Discord","page":"Contacts","title":"Discord","text":"","category":"section"},{"location":"contacts/","page":"Contacts","title":"Contacts","text":"join the discord chat   (Image: Discord) ","category":"page"},{"location":"API/analysis/mshort/#MShort","page":"MShort","title":"MShort","text":"","category":"section"},{"location":"API/analysis/mshort/","page":"MShort","title":"MShort","text":"Modules = [MShort]","category":"page"},{"location":"API/analysis/mshort/#MShort.MShort","page":"MShort","title":"MShort.MShort","text":"Predicates that signal lowered chances of success.\n\n\n\n\n\n","category":"module"},{"location":"API/analysis/mshort/#MShort.find-Tuple{AbstractDict}","page":"MShort","title":"MShort.find","text":"A good short should have high volume, (too) high price change, and dominating red candles.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/mshort/#MShort.fullret-Tuple{Any, Any, Any}","page":"MShort","title":"MShort.fullret","text":"Has a full retracement occurred?\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/mshort/#MShort.isbelow20-Tuple{Any, Any}","page":"MShort","title":"MShort.isbelow20","text":"Is the close below the Average?\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/mshort/#MShort.isbelow50-NTuple{4, Any}","page":"MShort","title":"MShort.isbelow50","text":"Is the close below the average with volume above average? Intended to be used on longer windows in contrast to the volume-less version. \n\n\n\n\n\n","category":"method"},{"location":"API/analysis/mshort/#MShort.isdcandles-Tuple{Any, Any}","page":"MShort","title":"MShort.isdcandles","text":"Are down candles more than up candles?\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/mshort/#MShort.lowhin-NTuple{4, AbstractVector}","page":"MShort","title":"MShort.lowhin","text":"True if series experienced a recent breakout with high volume retracement (Low out, High in). If breakout is not met, returns nothing. br: Breakout rule. window: How far backward to look for breakouts. delay: Delay to look for retracements.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/mshort/#MShort.mustd-Tuple{AbstractVector, Vararg{Any}}","page":"MShort","title":"MShort.mustd","text":"Breakout level. Mean with std.\n\n\n\n\n\n","category":"method"},{"location":"customizations/orders/#Custom-orders","page":"Orders","title":"Custom orders","text":"","category":"section"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"For example this is a sketch on how we can implement an OCO order type for simulations:","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"using OrderTypes: OrderType, @deforders\nabstract type OCOOrderType{S} <: OrderType{S}\n@deforders OCO","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"We can use the limitorder constructor function as template and tweak it for what we would need for an OCO order:","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"const _OCOOrderState = NamedTuple{(:committed, :filled, :trades, :twin), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Ref{OCOOrder{S where S}}}}\nfunction oco_order_state(\n    committed::Vector{T}, filled=[0.0], trades=Trade[]\n) where {T}\n    _OCOOrderState((committed, filled, trades, Ref{OCOOrder}()))\nend\nfunction ocoorder(\n    ai::AssetInstance,\n    ::SanitizeOff\n    ;\n    price_lower,\n    amount_lower,\n    price_upper,\n    amount_upper,\n    committed_lower,\n    committed_upper,\n    date,\n)\n    ismonotonic(price_lower, price_upper) || return nothing\n    iscost(ai, amount_lower, price_lower) || return nothing\n    iscost(ai, amount_upper, price_upper) || return nothing\n    lower_order = OrderTypes.Order(\n        ai,\n        OCOOrderType{Sell};\n        date,\n        price_lower,\n        amount_lower,\n        committed_lower,\n        attrs=oco_order_state(nothing, nothing, committed),\n    )\n    upper_order = OrderTypes.Order(\n        ai,\n        OCOOrderType{Buy};\n        date,\n        price_lower,\n        amount_lower,\n        committed_lower,\n        attrs=oco_order_state(nothing, nothing, committed),\n    )\n    lower_order.attrs[:twin] = upper_order\n    upper_order.attrs[:twin] = lower_order\n    return lower_order\nend","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"Now we add two pong! functions, one for order creation, and one for updates.","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"@doc \"Creates a simulated oco order.\"\nfunction pong!(\n    s::Strategy{Sim}, ::Type{Order{<:OCOOrderType}}, ai; date, kwargs...\n)\n    o = ocoorder(s, ai; date, kwargs...)\n    isnothing(o) && return nothing\n    iscommittable(s, o, ai) || return nothing\n    ## add logic to execute and return trades...\nend\n@doc \"Progresses a simulated oco order.\"\nfunction pong!(\n    s::Strategy{Sim}, ::Type{<:Order{OCOOrderType}}, date::Datetime, ai; kwargs...\n)\n    o = ocoorder(s, ai; date, kwargs...)\n    isnothing(o) && return nothing\n    iscommittable(s, o, ai) || return nothing\n    iscommittable(s, o.attrs.twin, ai) || return nothing\n    ## add logic to execute and return trades...\nend","category":"page"},{"location":"customizations/orders/#Custom-instruments","page":"Orders","title":"Custom instruments","text":"","category":"section"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"Instruments are also extendable, we have a simpler Asset and Derivative which are both subtypes of AbstractAsset, they are constructed following the CCXT naming scheme (QUOTE/BASE:SETTLE), the most basic expectation for instruments is that they have a baseand _quote_ currency.","category":"page"},{"location":"customizations/orders/#Instances-and-exchanges","page":"Orders","title":"Instances and exchanges","text":"","category":"section"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"Asset instances are parametrized with the type of asset (asset,derivative...) and an exchange. The parametrization over ExchangeID allows us to customize the execution for particular exchanges.","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"For example if in live mode we wanted to support OCO orders differently across exchanges we could write pong! functions that dispatch depending on the exchange parameter of the asset instance.","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"function pong!(\n    s::Strategy{Live}, ::Type{Order{<:OCOOrderType}}, ai::AssetInstance{A where A, ExchangeID{:bybit}}; date, kwargs...\n)\n### Call some private method of the ccxt exchange class to execute the order\nend","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"The above function would only dispatch to asset instances belonging to the exchange bybit.","category":"page"},{"location":"stats/#Stats","page":"Stats","title":"Stats","text":"","category":"section"},{"location":"stats/","page":"Stats","title":"Stats","text":"Within the stats package there are function that help you analyze the outcome of a backtest run.","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"using PingPong\nusing Stats\n\ns = strategy(:Example)\nStats.resample_trades(s, tf\"1d\")","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"In this case all the trades have been resampled with one day resolution, summing pnl of each trade for each trades asset in the strategy.","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"Stats.trades_balance(s, tf\"1d\")","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"trades_balance (which depends on trades_resample) calculates the cumulative total balance at each time frame using the column cum_total.","category":"page"},{"location":"stats/#Metrics","page":"Stats","title":"Metrics","text":"","category":"section"},{"location":"stats/","page":"Stats","title":"Stats","text":"Some common metrics used to analyze pnl are implemented, like sharpe, sortino, calmar, and expectancy.","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"Stats.sharpe(s, tf\"1d\", rfr=0.01)\nStats.sortino(s, tf\"1d\", rfr=0.01)\nStats.calmar(s, tf\"1d\")\nStats.expectancy(s, tf\"1d\")","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"The function multi is used to calc multiple metrics.","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"Stats.multi(s, :sortino, :calmar; tf=tf\"1d\", normalize=true)","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"normalize clamps the metric such that its value is always between 0 and 1. It does so by dividing by an arbitrary constant the value and then clipping between zero and one.","category":"page"},{"location":"API/prices/#Prices","page":"Prices","title":"Prices","text":"","category":"section"},{"location":"API/prices/","page":"Prices","title":"Prices","text":"Modules = [Prices]","category":"page"},{"location":"API/prices/#Main.Prices.gprofit","page":"Prices","title":"Main.Prices.gprofit","text":"Total profit of a ladder of trades\n\n\n\n\n\n","category":"function"},{"location":"API/prices/#Main.Prices.price_ranges","page":"Prices","title":"Main.Prices.price_ranges","text":"Given a price, output price at given ratios. (Predefined ratios - :bal,:futures,:tight,:expa)\n\n\n\n\n\n","category":"function"},{"location":"API/prices/#Main.Prices.price_ranges-Tuple{AbstractDict, Vararg{Any}}","page":"Prices","title":"Main.Prices.price_ranges","text":"Get the price range of a map of pairs, using the last available close price.\n\n\n\n\n\n","category":"method"},{"location":"customizations/exchanges/","page":"Exchanges","title":"Exchanges","text":"The bot focuses on crypto trading but you might want to use it for stock trading and plug it to brokers apis.  You need to use a different Exchange implementation. ","category":"page"},{"location":"customizations/exchanges/","page":"Exchanges","title":"Exchanges","text":"struct MyBroker <: Exchange\n...\nend","category":"page"},{"location":"customizations/exchanges/","page":"Exchanges","title":"Exchanges","text":"To get an overview of what is necessary to swap the main exchange struct you can look at the check function defined in the Exchanges module. Admittedly you might find implementing a compatible Exchange class not worth it compared to adding broker support directly into CCXT for the cost of paying the python round trip.","category":"page"},{"location":"customizations/exchanges/","page":"Exchanges","title":"Exchanges","text":"Eventually pingpong might get direct DEX support, either by plugging hummingbot connector middleware or by custom bot-to-node api implementations or through CCXT, depending on how CCXT might evolve.","category":"page"},{"location":"watchers/apis/coinpaprika/#CoinPaprika","page":"CoinPaprika","title":"CoinPaprika","text":"","category":"section"},{"location":"watchers/apis/coinpaprika/#API","page":"CoinPaprika","title":"API","text":"","category":"section"},{"location":"watchers/apis/coinpaprika/","page":"CoinPaprika","title":"CoinPaprika","text":"Modules = [Watchers.CoinPaprika]","category":"page"},{"location":"API/executors/#Engine","page":"Engine","title":"Engine","text":"","category":"section"},{"location":"API/executors/","page":"Engine","title":"Engine","text":"Modules = [PingPong.Engine]","category":"page"},{"location":"API/executors/#Base.fill!-Tuple{Collections.AssetCollection, Vararg{Any}}","page":"Engine","title":"Base.fill!","text":"Main.Engine.Instances.fill! all the instances with given timeframes data...\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.fill!-Tuple{Instances.AssetInstance15, Vararg{Any}}","page":"Engine","title":"Base.fill!","text":"Pulls data from storage, or resample from the shortest timeframe available.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Data.stub!-Tuple{Collections.AssetCollection, Any}","page":"Engine","title":"Data.stub!","text":"Replaces the data of the asset instances with src which should be a mapping. Used for backtesting.\n\nsrc: The mapping, should be a pair TimeFrame => Dict{String, PairData}.\n\nExample:\n\nusing Scrapers.BinanceData as bn\nusing Strategies\nusing Exchanges\nsetexchange!(:binanceusdm)\ncfg = Config(nameof(exc.id))\nstrat = strategy!(:Example, cfg)\ndata = bn.binanceload()\nstub!(strat.universe, data)\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinmarketcap/#CoinMarketCap","page":"CoinMarketCap","title":"CoinMarketCap","text":"","category":"section"},{"location":"watchers/apis/coinmarketcap/#API","page":"CoinMarketCap","title":"API","text":"","category":"section"},{"location":"watchers/apis/coinmarketcap/","page":"CoinMarketCap","title":"CoinMarketCap","text":"Modules = [Watchers.CoinMarketCap]","category":"page"},{"location":"API/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"API/plotting/","page":"Plotting","title":"Plotting","text":"Modules = [ Plotting ]\nPrivate = false\nPublic = true","category":"page"},{"location":"API/analysis/mvp/#MVP","page":"MVP","title":"MVP","text":"","category":"section"},{"location":"API/analysis/mvp/","page":"MVP","title":"MVP","text":"Modules = [MVP]","category":"page"},{"location":"API/analysis/mvp/#MVP.MVP","page":"MVP","title":"MVP.MVP","text":"Momentum, volume, price indicator.\n\n\n\n\n\n","category":"module"},{"location":"API/analysis/mvp/#MVP.discrete_mvp-Tuple{AbstractDict{String, Data.PairData}}","page":"MVP","title":"MVP.discrete_mvp","text":"\n\n\n\n","category":"method"},{"location":"API/analysis/mvp/#MVP.is_mvp-Tuple{AbstractVector, AbstractVector}","page":"MVP","title":"MVP.is_mvp","text":"Returns the mvp-ness of a pair as a sum of each condition ratio weighted by weights. If real=false it will return a Bool indicating if the pair passes the given ratios.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/mvp/#MVP.momentum-Tuple{AbstractVector}","page":"MVP","title":"MVP.momentum","text":"Ratio is the minimum number of green candles required.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/mvp/#MVP.volume-Tuple{AbstractVector}","page":"MVP","title":"MVP.volume","text":"Ratio is the minimum percent increment of volume from the first half of the series.\n\n\n\n\n\n","category":"method"},{"location":"API/collections/#Collections","page":"Collections","title":"Collections","text":"","category":"section"},{"location":"API/collections/","page":"Collections","title":"Collections","text":"Modules = [PingPong.Engine.Collections]","category":"page"},{"location":"API/collections/#Collections.AssetCollection","page":"Collections","title":"Collections.AssetCollection","text":"A collection of assets instances, indexed by asset and exchange identifiers.\n\n\n\n\n\n","category":"type"},{"location":"API/collections/#TimeTicks.DateRange","page":"Collections","title":"TimeTicks.DateRange","text":"Makes a daterange that spans the common min and max dates of the collection.\n\n\n\n\n\n","category":"type"},{"location":"API/collections/#Collections.bqe-Union{Tuple{T}, Tuple{DataFrames.DataFrame, T, T, T}} where T<:Symbol","page":"Collections","title":"Collections.bqe","text":"Dispatch based on either base, quote currency, or exchange.\n\n\n\n\n\n","category":"method"},{"location":"API/collections/#Collections.flatten-Tuple{Collections.AssetCollection}","page":"Collections","title":"Collections.flatten","text":"Returns a Dict{TimeFrame, DataFrame} of all the OHLCV dataframes present in the asset collection.\n\n\n\n\n\n","category":"method"},{"location":"API/collections/#Collections.iscashable-Tuple{Instruments.AbstractCash, Collections.AssetCollection}","page":"Collections","title":"Collections.iscashable","text":"Checks that all assets in the universe match the cash.\n\n\n\n\n\n","category":"method"},{"location":"disambiguation/","page":"Disambiguation","title":"Disambiguation","text":"There may be many terms used through out the code base that can semantically mean the same thing, so it can be confusing when trying to understand what a function does, here is a list to should clear up at least some of them:","category":"page"},{"location":"disambiguation/","page":"Disambiguation","title":"Disambiguation","text":"asset: an asset is a structure constructed from parsing a symbol, usually we mean either an simple Asset or a Derivative or an AssetInstance. Many times asset instances variables are named ai, and plain assets either a or aa (AbstractAsset).\nsym: In julia Symbol is a built in type, but many times in trading context a \"symbol\" represents an association between a base currency and a quote currency. There isn't a clear distinction here about when we call things as sym. But most of the times it is either a Symbol if it is only a currency or a String if it is a pair.\npair: it is most of the times a String (or a SubString) of the form \"$BASE/$QUOTE\" (note the slash in-between).\nbc,qc: variables that have this name are base or quote currency symbols, like the ones accessed as fields of an AbstractAsset, and they are indeed of type Symbol.\nfutures/swap/perps: swaps are futures, but they are a kind of \"perpetual futures\" so they have distinct naming. Following ccxt conventions, if its a swap the raw symbol is of the form \"$BASE/$QUOTE:$SETTLE\", if it is a plain \"future\" contract then it will have an expiry date attached like \"$BASE/$QUOTE:$SETTLE-EXPIRY\"\namount: when we talk about amounts, we usually mean the quantity in base currency. If we buy 100$ worth of BTC priced at 1000$, then our amount will be 100/1000 == 0.1BTC\nprice: it is always the quotation of the base currency. BTC price is 1000$ if 1BTC / 1$ == 1000\nsize: it is most of the times the quantity in quote currency spent to execute a trade, it includes fees.\nlong/short: long and short are terms only used in the context of margin trading.\nohlc/v: usually a dataframe of ohlcv data\npairdata: a \"lower\" kind of data structure that represents an association between a dataframe, a zarr array, and a pair.\nexc/exchange: either an Exchange instance, or an ExchangeID, or just the Symbol of an exchange id. There is a global exc variable in the ExchangeTypes module that is defined for convenience when working in the repl.\nsandbox: many exchanges provide a \"testnet\" to test api endpoints, be ware that it has nothing to do with paper trading.\ninstance: most of the times it means an asset instance (AssetInstance).\ncandle: it is either a dataframe row (from an ohlcv dataframe) or a named tuple, or an actual Candle struct.\nresample: when we resample we usually mean down sampling since up sampling is rarely useful.\nside/position: when we use the word side we usually mean either buy or sell. When instead we mean the \"side of a position\", long or short we just use the word position. The side of a trade is either buy or sell, the position of a trade is either long or short.","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Precompilation-fails","page":"Troubleshooting","title":"Precompilation fails","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"A repo update might have added some dependencies. If there are problems with precompilation ensure all the packages are resolved.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"include(\"resolve.jl\")\nrecurse_projects() # optional ;update=true","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you are not doing it already, try to load the repl passing the project as arg, e.g.:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"julia --project=./PingPong","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Avoid starting a repl and then calling Pkg.activate(\".\") when precompiling.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Precompilation of things that depend on python (like exchange functions) can cause segfaults. Some famous suspects that can cause dangling pointers in the precompiled code are:\nglobal caches, like the tickers_cache, since the content of global constants is serialized by precompilation, make sure that those constants are empty during precompilation.\nmacros like @py can rewrite code putting in place python objects. Avoid use of those macros in functions that you want precompiled.\nIf some package keeps skipping precompilation, it is likely that the JULIA_NOPRECOMP env var contains dependencies of such package.","category":"page"},{"location":"troubleshooting/#Python-can't-find-modules","page":"Troubleshooting","title":"Python can't find modules","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If python complains about missing dependencies, while in the julia REPL, with this repository as the activated project, do this:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"; find ./ -name .CondaPkg | xargs -I {} rm -r {} # Delete existing conda environments\nusing Python # Loads our python wrapper around CondaPkg which fixes `PYTHONPATH` env var\nimport Pkg; Pkg.instantiate()","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Alternatively force CondaPkg env resolution, from julia --project.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using Python.PythonCall.C.CondaPkg\nCondaPkg.resolve(force=true)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"restart the REPL.","category":"page"},{"location":"troubleshooting/#It-is-unresponsive","page":"Troubleshooting","title":"It is unresponsive","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If the exchange instance has been idle for quite a while the connection might have been closed. It should fail according to the ccxt exchange timeout, although more often than not it takes longer. After the inevitable timeout error the connection is re-established and subsequent functions that rely on api calls should become responsive again.","category":"page"},{"location":"troubleshooting/#Can't-save-data","page":"Troubleshooting","title":"Can't save data","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you are using LMDB with zarr (which is default) the initial db size is 64MB. To increase it:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using Data\nzi = zilmdb()\nData.mapsize!(zi, 1024) # This will set the max DB size to 1GB\nData.mapsize!!(zi, 100) # Double bang (!!) will _add_ to the previous mapsize (in this case 1.1GB)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Whenever the stored data reaches the mapsize, you have to increase it.","category":"page"},{"location":"troubleshooting/#Plotting-tooltips-are-unaligned","page":"Troubleshooting","title":"Plotting tooltips are unaligned","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Likely a bug with WGLMakie, use GLMakie instead:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using GLMakie\nGLMakie.activate!()","category":"page"},{"location":"API/instances/#Instances","page":"Instances","title":"Instances","text":"","category":"section"},{"location":"API/instances/","page":"Instances","title":"Instances","text":"Modules = [PingPong.Engine.Instances]","category":"page"},{"location":"API/instances/#Instances.LEVERAGE_PRECISION","page":"Instances","title":"Instances.LEVERAGE_PRECISION","text":"The number of digits allowed for leverage values.\n\n\n\n\n\n","category":"constant"},{"location":"API/instances/#Instances.POSITION_PRECISION","page":"Instances","title":"Instances.POSITION_PRECISION","text":"The number of digits to keep for margin calculations.\n\n\n\n\n\n","category":"constant"},{"location":"API/instances/#Instances.AssetInstance15","page":"Instances","title":"Instances.AssetInstance15","text":"An asset instance holds all known state about an asset, i.e. BTC/USDT:\n\nasset: the identifier\ndata: ohlcv series\nhistory: the trade history of the pair\ncash: how much is currently held, can be positive or negative (short)\nexchange: the exchange instance that this asset instance belongs to.\nlimits: minimum order size (from exchange)\nprecision: number of decimal points (from exchange)\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.Position","page":"Instances","title":"Instances.Position","text":"A position tracks the margin state of an asset instance:\n\ntimestamp: last update time of the position (DateTime)\nside: the side of the position <:PositionSide Long or Short\ntiers: sorted dict of all the leverage tiers\ncash: it is the notional value of the position\n\nFor the rest of the fields refer to  ccxt docs\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Base.isopen-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Base.isopen","text":"Check if an asset position is open.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.iszero-Tuple{Instances.AssetInstance15, Any}","page":"Instances","title":"Base.iszero","text":"Test if some amount (base currency) is zero w.r.t. an asset instance min limit.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.iszero-Tuple{Instances.AssetInstance15, Misc.PositionSide}","page":"Instances","title":"Base.iszero","text":"Test if asset cash is zero.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.iszero-Tuple{Instances.AssetInstance15}","page":"Instances","title":"Base.iszero","text":"Test if asset cash is zero.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.position-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Misc.Long, Type{Misc.Long}, OrderTypes.Trade{O, A, E, Misc.Long}, OrderTypes.LongOrder{O, A, E}} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}","page":"Instances","title":"Base.position","text":"Asset instance long position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.position-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Misc.Short, Type{Misc.Short}, OrderTypes.Trade{O, A, E, Misc.Short}, OrderTypes.ShortOrder{O, A, E}} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}","page":"Instances","title":"Base.position","text":"Asset instance short position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.position-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin}","page":"Instances","title":"Base.position","text":"Returns the last open asset position or nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.position-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Base.position","text":"Asset position by order.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.similar-Tuple{Instances.AssetInstance15}","page":"Instances","title":"Base.similar","text":"Returns a similar asset instance with cash and orders reset.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Data.candlelast-Tuple{Instances.AssetInstance15, TimeFrames.TimeFrame, Dates.DateTime}","page":"Instances","title":"Data.candlelast","text":"Get the last available candle strictly lower than apply(tf, date)\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#ExchangeTypes.exchangeid-Union{Tuple{Instances.AssetInstance15{<:AbstractAsset, E}}, Tuple{E}} where E<:ExchangeID","page":"Instances","title":"ExchangeTypes.exchangeid","text":"ExchangeID for the asset instance.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Exchanges.tier-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Exchanges.tier","text":"Asset position tier.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances._roundpos","page":"Instances","title":"Instances._roundpos","text":"Round function for values of position fields.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.additional!","page":"Instances","title":"Instances.additional!","text":"Sets additional margin (should always be positive).\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.additional-Tuple{Instances.Position}","page":"Instances","title":"Instances.additional","text":"Position additional margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.additional-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.additional","text":"Asset position additional margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.addmargin!-Tuple{Instances.Position, Any}","page":"Instances","title":"Instances.addmargin!","text":"Adds margin to a position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.bankruptcy-Tuple{Real, Real}","page":"Instances","title":"Instances.bankruptcy","text":"The price where the position is fully liquidated.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.bankruptcy-Union{Tuple{P}, Tuple{Any, Any, Type{P}}} where P<:Misc.PositionSide","page":"Instances","title":"Instances.bankruptcy","text":"The price where the asset position is fully liquidated.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.committed-Tuple{Instances.Position}","page":"Instances","title":"Instances.committed","text":"Position locked in pending orders.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.entryprice!","page":"Instances","title":"Instances.entryprice!","text":"Update the entry price.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.instance","page":"Instances","title":"Instances.instance","text":"Constructs an asset instance loading data from a zarr instance. Requires an additional external constructor defined in Engine.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.isdust-Tuple{Instances.AssetInstance15, Any}","page":"Instances","title":"Instances.isdust","text":"True if the asset value is below minimum quantity.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.isdust-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, Misc.PositionSide}","page":"Instances","title":"Instances.isdust","text":"True if the position value of the asset is below minimum quantity.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.leverage!-Tuple{Any, Any, Misc.PositionSide}","page":"Instances","title":"Instances.leverage!","text":"Updates asset position leverage for asset instance.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.leverage!-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.CrossMargin, Misc.PositionSide, Val{:max}}","page":"Instances","title":"Instances.leverage!","text":"Some exchanges consider a value of 0 leverage as max leverage for the current tier (in cross margin mode).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.leverage!-Tuple{Instances.Position, Any}","page":"Instances","title":"Instances.leverage!","text":"Updates position leverage.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.leverage-Tuple{Instances.Position}","page":"Instances","title":"Instances.leverage","text":"Position leverage.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.leverage-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.leverage","text":"Asset position leverage.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice!-Tuple{Instances.Position{Misc.Long}, Any}","page":"Instances","title":"Instances.liqprice!","text":"Sets the liquidation price for a long position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice!-Tuple{Instances.Position{Misc.Short}, Any}","page":"Instances","title":"Instances.liqprice!","text":"Sets the liquidation price for a short position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice!-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.liqprice!","text":"Sets asset position liquidation price.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice-Tuple{Instances.Position}","page":"Instances","title":"Instances.liqprice","text":"Position liquidation price.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.liqprice","text":"Asset position liquidation price.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.load!-Tuple{Instances.AssetInstance15}","page":"Instances","title":"Instances.load!","text":"Load ohlcv data of asset instance.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.maintenance!-Tuple{Instances.Position, Any}","page":"Instances","title":"Instances.maintenance!","text":"Sets maintenance margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.maintenance-Tuple{Instances.Position}","page":"Instances","title":"Instances.maintenance","text":"Position maintenance margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.maintenance-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.maintenance","text":"Asset position maintenance margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.makerfees-Tuple{Instances.AssetInstance15}","page":"Instances","title":"Instances.makerfees","text":"Maker fees for the asset instance (usually lower than taker fees.)\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.margin!-Tuple{Instances.Position}","page":"Instances","title":"Instances.margin!","text":"Sets initial margin given notional and leverage values.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.margin-Tuple{Instances.Position}","page":"Instances","title":"Instances.margin","text":"Position initial margin (includes additional).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.margin-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.margin","text":"Asset position initial margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.maxfees-Tuple{Instances.AssetInstance15}","page":"Instances","title":"Instances.maxfees","text":"The maximum fees for trading in the asset market (usually the lowest vip level.)\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.minfees-Tuple{Instances.AssetInstance15}","page":"Instances","title":"Instances.minfees","text":"The minimum fees for trading in the asset market (usually the highest vip level.)\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.mmr-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, Union{Type{P}, OrderTypes.Order{O, A, E, P}, OrderTypes.Trade{O, A, E, P}, P} where {P<:Misc.PositionSide, O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}","page":"Instances","title":"Instances.mmr","text":"Asset position maintenance margin rate.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.mmr-Tuple{Instances.Position}","page":"Instances","title":"Instances.mmr","text":"Position maintenance margin rate.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.nondust","page":"Instances","title":"Instances.nondust","text":"Returns the asset cash rounded to precision.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.notional!-Tuple{Instances.Position, Any}","page":"Instances","title":"Instances.notional!","text":"Update the notional value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.notional-Tuple{Instances.Position}","page":"Instances","title":"Instances.notional","text":"Position notional value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.notional-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.notional","text":"Asset position notional value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.pnl","page":"Instances","title":"Instances.pnl","text":"Calc PNL for long position given current_price as input.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.pnl-2","page":"Instances","title":"Instances.pnl","text":"Calc PNL for short position given current_price as input.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.pnl-Union{Tuple{P}, Tuple{Any, Union{Type{P}, OrderTypes.Order{O, A, E, P}, OrderTypes.Trade{O, A, E, P}, P} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}, Any}} where P","page":"Instances","title":"Instances.pnl","text":"The pnl of an asset position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.pnlpct-Tuple{Instances.Position, Any}","page":"Instances","title":"Instances.pnlpct","text":"Calc PNL percentage.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.pnlpct-Union{Tuple{P}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{P}, OrderTypes.Order{O, A, E, P}, OrderTypes.Trade{O, A, E, P}, P} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}, Any}} where P","page":"Instances","title":"Instances.pnlpct","text":"The pnl percentage of an asset position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.price-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, Misc.NoMargin}, Any, Vararg{Any}}","page":"Instances","title":"Instances.price","text":"Asset entry price.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.price-Tuple{Instances.Position}","page":"Instances","title":"Instances.price","text":"Position entryprice.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.price-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.price","text":"Asset entry price.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.status!-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Misc.PositionSide, Instances.PositionStatus}","page":"Instances","title":"Instances.status!","text":"Opens or closes the status of an non-hedged position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.status!-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Union{Misc.CrossMargin{Misc.Hedged}, Misc.IsolatedMargin{Misc.Hedged}}, Misc.PositionSide, Instances.PositionStatus}","page":"Instances","title":"Instances.status!","text":"Opens or closes the status of an hedged position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.status-Tuple{Instances.Position}","page":"Instances","title":"Instances.status","text":"Position status (open or closed).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.status-Union{Tuple{S}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, OrderTypes.Order{O, A, E, S}, OrderTypes.Trade{O, A, E, S}, S} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.status","text":"Asset position status (open or closed).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.takerfees-Tuple{Instances.AssetInstance15}","page":"Instances","title":"Instances.takerfees","text":"Taker fees for the asset instance (usually higher than maker fees.)\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.tier!","page":"Instances","title":"Instances.tier!","text":"Updates position leverage tier according to size.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instruments.cash-Tuple{Instances.Position}","page":"Instances","title":"Instruments.cash","text":"Held position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.value-Union{Tuple{P}, Tuple{Any, Union{Type{P}, OrderTypes.Order{O, A, E, P}, OrderTypes.Trade{O, A, E, P}, P} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where P","page":"Instances","title":"Instruments.value","text":"The value held by the position, margin with pnl minus fees.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.opposite-Union{Tuple{P}, Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Instances.Position{P}, P}}} where P","page":"Instances","title":"Misc.opposite","text":"The opposite position w.r.t. the asset instance and another Position or PositionSide.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.reset!-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, Misc.NoMargin}, Vararg{Any}}","page":"Instances","title":"Misc.reset!","text":"Resets asset cash and committments.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.reset!-Tuple{Instances.AssetInstance15{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Vararg{Any}}","page":"Instances","title":"Misc.reset!","text":"Resets asset positions.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.reset!-Tuple{Instances.Position, Val{:full}}","page":"Instances","title":"Misc.reset!","text":"Resets position to initial state.\n\nwarning: Also resets leverage\nWhen reopening a position, leverage should be set again.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.reset!-Tuple{Instances.Position}","page":"Instances","title":"Misc.reset!","text":"Resets the bare fields to close a position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.@_round","page":"Instances","title":"Instances.@_round","text":"Rounds a value based on the precision field of the ai asset instance. [amount].\n\n\n\n\n\n","category":"macro"},{"location":"API/instances/#Instances.@ramount-Tuple{Any}","page":"Instances","title":"Instances.@ramount","text":"Rounds a value based on the precision (amount) field of the ai asset instance.\n\n\n\n\n\n","category":"macro"},{"location":"API/instances/#Instances.@rprice-Tuple{Any}","page":"Instances","title":"Instances.@rprice","text":"Rounds a value based on the precision (price) field of the ai asset instance.\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/#Precompilations","page":"Devdocs","title":"Precompilations","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Functions that should be precompiled","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Python: clearpath!\nData: ZarrInstance, ZGroup, zopen, get_zgroup\nMisc: empty!(::Config)\nCPython __init__(?)","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Precompilation can be skipped for some modules, by setting JULIA_NOPRECOMP env var:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"ENV[\"JULIA_NOPRECOMP\"] = (:PingPong, :Scrapers, :Engine, :Watchers, :Plotting, :Stats)","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"or use direnv, (see the .envrc in the repository). Setting JULIA_NOPRECOMP=all disables precompilation entirely for some packages, it should be used only when modifying low level pieces of the modules stack. When switching between all, and custom lists remember to purge the compile cache:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"include(\"resolve.jl\")\npurge_compilecache() # If you pass a local package name it will only purge that package comp cache","category":"page"},{"location":"devdocs/#Methods-invalidations","page":"Devdocs","title":"Methods invalidations","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"The sequence of using ... statements to load modules can be important to consider, although only for the first instance for a particular module is critical. That's because when a module is loaded, methods insertion can trigger invalidation. If you order the modules loading from the most likley to invalidate, to the least one, less methods will be invalidated and the top module will load faster. For example in case of modules that depend on the Python, making python the top most statemenet can improve loading times, e.g.:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"# load invalidation heavy modules first\nusing Python\nusing Ccxt\n# load lightweight modules later\nusing Timeticks\nusing Lang","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Invalidation heavy modules list:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Python\nCcxt (starts the python async loop)\nData (depends on Zarr and DataFrames)\nPlots (makie dependency)","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"In general if one of our local package depends on some heavy package, the chances that it will trigger many methods invalidations is high. This is also why it is important to always add an external module to 1 and only 1 local package and use the local package as dependency to other local packages, e.g.:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"We choose to make DataFrames a dependency to the local package Data, but we want to use the DataFrames module from our Stats package. We should not add DataFrames the deps of Stats, instead we Data and import DataFrames from Data like so:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"module Stats\n\nusing Data.DataFrames\n\n# ...\nend","category":"page"},{"location":"devdocs/#Adding-dependencies","page":"Devdocs","title":"Adding dependencies","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Only add a dependency to one of the subpackages, when using the same dependency from another subpackage, add the subpackage that already has that dependency instead of the dependency itself.","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"When adding using or imports statements inside packages you must consider their order. The rule of thumb is to always import from the most downstream package to the most upstream. This reduces the amount of invalidations happening as packages are inserted into the method tables.","category":"page"},{"location":"devdocs/#Customizations-and-the-type-hierarchy","page":"Devdocs","title":"Customizations and the type hierarchy","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"If you look at the package OrderTypes (or EventTypes) there are multiple definition for dispatching functions on orders whether they are buy,sell,long,short. Care must be taken for ensuring that dispatching works as intended because multiple definitions that might trick you into thinking they are similar, they are not:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"struct One{T} end\nstruct Two{T} end\nTypeAlias1{A} = Two{<:One}\nTypeAlias2{A<:One} = Two{A}","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"If you parametrize on the alias, the type deref won't carry over the parameter restriction, so if you have another type TypeAlias3{A<:Two} = Two{A} it will dispatch to the same func as TypeAlias2 ignoring the <:One and <:Two restriction. As a rule of thumb, restrict subtyping to the right side to ensure dispatching works as intended.","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"warning: Testing dispatch while using Revise\nRevise can trick you into thinking dispatching is working correctly while in practice you might have just redefined a new method on the same parameters, more over, because revise doesn't delete old method if still in use, it might look like dispatching is working, whereas some parts are using deleted methods that are not anymore in the code base. For this reason, when you notice inconsistencies, start from a fresh repl, and optionally purge the compile cache.","category":"page"},{"location":"devdocs/#Dependency-graph","page":"Devdocs","title":"Dependency graph","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"This shows a graph where the red circled packages are our own packages. (Image: PingPong dependencies graph)","category":"page"},{"location":"devdocs/#Limit-orders-flowchart","page":"Devdocs","title":"Limit orders flowchart","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"(Image: Limit Orders Flowchart)","category":"page"},{"location":"devdocs/#Market-orders-flowchart","page":"Devdocs","title":"Market orders flowchart","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"(Image: Market Orders Flowchart)","category":"page"},{"location":"customizations/customizations/#Extending-the-framework/bot","page":"Overview","title":"Extending the framework/bot","text":"","category":"section"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"There are parametrized types for:","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"strategies\nassets\ninstances\norders and trades.\nexchanges","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"The strategy parametrization is what allows us to implement the ping pong model by separating simulations from live executions, the rest can be used to implement custom logic behaviour.","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"An exchange offers a unique order type? you can implement it by defining a new order type like:","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"using OrderTypes\nabstract type MyCustomOrderType{S} <: OrderType{S} end","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"Then you implement the functions where the logic diverges from standard market/limit orders. You might find that the order execution to be quite fine grained, which should allow you to implement the cusomization by defining the minimum amount of functions possible while avoid touch things that might behave the same as limit or market orders. If that is not the case, file an issue.","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"Another common thing that can happen is that the exchange where you are trading behaves inconsistently over the interface. Despite CCXT unifying a good chunk of the api, many exchanges still remain where the private api might be required. Again look into the api and see what is worth overriding, if some function is too big, we might split it and allow for easier dispatching.","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"Many functions take the strategy as arguments, and strategies always have their name within the types parameters, so you can always define \"snowflake\" functions that only work for a specific strategy, use this flexibility wisely as to avoid complexity bankruptcy.","category":"page"},{"location":"API/analysis/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"API/analysis/analysis/","page":"Analysis","title":"Analysis","text":"This module is pretty much a playground of functions that I am using/used, most likely of very little interest.","category":"page"},{"location":"API/analysis/analysis/","page":"Analysis","title":"Analysis","text":"Modules = [Analysis]","category":"page"},{"location":"API/analysis/analysis/#Analysis.fltsummary-Tuple{AbstractVector{Tuple{AbstractFloat, Data.PairData}}}","page":"Analysis","title":"Analysis.fltsummary","text":"Return the summary of a filtered vector of pairdata.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.mark!-Tuple{}","page":"Analysis","title":"Analysis.mark!","text":"Loads the Mark module.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Base.filter-Tuple{Function, AbstractDict, Real, Real}","page":"Analysis","title":"Base.filter","text":"Filters a list of pairs using a predicate function. The predicate functions must return a Real number which will be used for sorting.\n\n\n\n\n\n","category":"method"},{"location":"strategy/#Strategy-interface","page":"Strategies","title":"Strategy interface","text":"","category":"section"},{"location":"strategy/#Load-a-strategy","page":"Strategies","title":"Load a strategy","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The strategy is instantiated by loading a julia module at runtime.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"using PingPong\ncfg = Config(:kucoin) # Load the configuration, choosing kucoin as exchange\nstrategy!(:Example, cfg) # Load the Example strategy","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The strategy is looked up inside the config under the sources key:","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"# Example config\n[kucoin]\nfutures = true\n[sources]\nExample = \"cfg/strategies/Example.jl\" # the name of the module","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The key is the name of the module (in this case Example) which will be imported from the included file \"cfg/strategies/Example.jl\".","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"After the strategy module is imported the strategy is instantiated by calling the ping!(::Type{S}, ::LoadStrategy, cfg) function.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"> typeof(s)\nEngine.Strategies.Strategy37{:Example, ExchangeTypes.ExchangeID{:kucoin}(), :USDT}","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"See here how the load method is defined.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"module Example\nusing PingPong\n@strategyenv!\n\nconst NAME = :Example\nconst EXCID = ExchangeID(:phemex)\nconst S{M} = Strategy{M,NAME,typeof(EXCID),NoMargin,:USDT}\nconst TF = tf\"1m\"\n\nfunction ping!(::Type{S}, ::LoadStrategy, config)\n    assets = marketsid(S)\n    s = Strategy(Example, assets; config)\n    s\nend\n\nend","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"See that the load method dispatches on the strategy type with cfg as argument of type Misc.Config.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"As a rule of thumb if the method should be called before the strategy is construct, then it dispatches to the strategy type (Type{S}), otherwise the strategy instance (S). For convention the module property S of your strategy module, declares the strategy type (const S = Strategy{name, exc, ...}).","category":"page"},{"location":"strategy/#Strategy-interface-2","page":"Strategies","title":"Strategy interface","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"Both ping! and pong! functions adhere to a convention for function signatures. The first argument is always  either an instance of the subject or its type, followed by the arguments of the function, with the last non kw argument being the verb which describes the purpose of the function. KW arguments are optional and don't have any requirements. We can see below that Type{S} is the subject, config is an argument, and ::LoadStrategy is the _verb.","category":"page"},{"location":"strategy/#List-of-strategy-ping!-functions","page":"Strategies","title":"List of strategy ping! functions","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"Engine.Strategies.ping!","category":"page"},{"location":"strategy/#Strategies.ping!","page":"Strategies","title":"Strategies.ping!","text":"Called on each timestep iteration, possible multiple times. Receives:\n\ncurrent_time: the current timestamp to evaluate (the current candle would be current_time - timeframe).\nctx: The context of the executor.\n\nping!(\n    _::Strategies.Strategy,\n    current_time::Dates.DateTime,\n    ctx\n)\n\n\n\n\n\n\nCalled to construct the strategy, should return the strategy instance.\n\nping!(\n    _::Type{<:Strategies.Strategy},\n    cfg,\n    _::Strategies.LoadStrategy\n)\n\n\n\n\n\n\nCalled at the end of the reset! function applied to a strategy.\n\nping!(_::Strategies.Strategy, _::Strategies.ResetStrategy)\n\n\n\n\n\n\nHow much lookback data the strategy needs. \n\nping!(\n    s::Strategies.Strategy,\n    _::Strategies.WarmupPeriod\n) -> Any\n\n\n\n\n\n\nWhen an order is cancelled the strategy is pinged with an order error. \n\nping!(\n    ::Strategies.Strategy,\n    ::OrderTypes.Order,\n    err::OrderTypes.OrderError,\n    ::Instances.AssetInstance15;\n    kwargs...\n) -> OrderTypes.OrderError\n\n\n\n\n\n\nAfter a position was updated from a trade. \n\nping!(\n    _::Strategies.Strategy{X, N, <:ExchangeID, <:Misc.WithMargin, C} where {X<:Misc.ExecMode, N, C},\n    ai,\n    trade::OrderTypes.Trade,\n    _::Instances.Position,\n    _::Instances.PositionChange\n)\n\n\n\n\n\n\nAfter a position update from a candle. \n\nping!(\n    _::Strategies.Strategy{X, N, <:ExchangeID, <:Misc.WithMargin, C} where {X<:Misc.ExecMode, N, C},\n    ai,\n    date::Dates.DateTime,\n    _::Instances.Position,\n    _::Instances.PositionUpdate\n)\n\n\n\n\n\n\nHas to return a Optimizations.ContextSpace named tuple where ctx (Executors.Context) is the time period to backtest and the space is either an already constructed subtype of BlackBoxOptim.SearchSpace or a tuple (Symbol, args...) for a search space pre-defined within the BBO package.\n\n\n\n\n\nThis ping function should apply the parameters to the strategy, called before the backtest is performed. \n\n\n\n\n\n","category":"function"},{"location":"engine/paper/#Running-in-paper-mode","page":"Paper","title":"Running in paper mode","text":"","category":"section"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"To construct a strategy in paper mode you can specify the default mode in the user/config.toml file, or in the Project.toml file of your strategy project, or by passing the mode as a keyword argument:","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"[Example]\nmode = \"Paper\"","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"using Strategies\ns = strategy(:Example, mode=Paper())","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"Start the strategy:","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"using PaperMode\npaper!(s)","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"Expect logging output:","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"┌ Info: Starting strategy ExampleMargin in paper mode!\n│ \n│     throttle: 5 seconds\n│     timeframes: 1m(main), 1m(optional), 1m 15m 1h 1d(extras)\n│     cash: USDT: 100.0 (on phemex) [100.0]\n│     assets: ETH/USDT:USDT, BTC/USDT:USDT, SOL/USDT:USDT\n│     margin: Isolated()\n└     \n[ Info: 2023-07-07T04:49:51.051(ExampleMargin@phemex) 0.0/100.0[100.0](USDT), orders: 0/0(+/-) trades: 0/0/0(L/S/Q)\n[ Info: 2023-07-07T04:49:56.057(ExampleMargin@phemex) 0.0/100.0[100.0](USDT), orders: 0/0(+/-) trades: 0/0/0(L/S/Q)","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"Running the strategy as a task","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"paper!(s, foreground=false)","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"Logs will be written either to the strategy s[:logfile] key if present or the output of PaperMode.paperlog(s).","category":"page"},{"location":"engine/paper/#How-paper-mode-works.","page":"Paper","title":"How paper mode works.","text":"","category":"section"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"When you start paper mode asset prices are monitored in real time from the exchange. Orders execution is similar to SimMode, but the actual price and the amount trade and the orders execution sequence is dependent on the exchange data. ","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"Market orders are executed by looking at the orderbook, and sweeping the bids/asks available on it, the final price and amount is therefore the average of all the orderbook entries available on the orderbook.\nLimit orders also sweep the orderbook, but only for the bids/asks that fall below the limit price of the order. If the order is not yet fully filled (and is a GTC order) a task is spawned that constantly watches the trades history from the exchange. Trades that fall within the order limit price will be used to fill the remaining limit order amount. ","category":"page"},{"location":"API/analysis/mlong/#MLong","page":"MLong","title":"MLong","text":"","category":"section"},{"location":"API/analysis/mlong/","page":"MLong","title":"MLong","text":"Modules = [MLong]","category":"page"},{"location":"API/analysis/mlong/#MLong.MLong","page":"MLong","title":"MLong.MLong","text":"Predicates that signal increased chances of success.\n\n\n\n\n\n","category":"module"},{"location":"API/strategies/#Strategies","page":"Strategies","title":"Strategies","text":"","category":"section"},{"location":"API/strategies/","page":"Strategies","title":"Strategies","text":"Modules = [Engine.Strategies]","category":"page"},{"location":"API/strategies/#Strategies.Strategy","page":"Strategies","title":"Strategies.Strategy","text":"The strategy is the core type of the framework.\n\nThe strategy type is concrete according to:\n\nName (Symbol)\nExchange (ExchangeID), read from config\nQuote cash (Symbol), read from config\n\nThe exchange and the quote cash should be specified from the config, or the strategy module.\n\nuniverse: All the assets that the strategy knows about\nholdings: assets with non zero balance.\nbuyorders: active buy orders\nsellorders: active sell orders\ntimeframe: the smallest timeframe the strategy uses\ncash: the quote currency used for trades\ncash_committed: cash kept busy by pending orders\nconfig: The Config the strategy was instantiated with.\nlogs: logs exchange events like positions updates.\n\nConventions for strategy defined attributes:\n\nNAME: the name of the strategy could be different from module name\nS: the strategy type.\nTF: the smallest timeframe that the strategy uses\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Instruments.freecash-Tuple{Strategies.Strategy}","page":"Strategies","title":"Instruments.freecash","text":"Cash that is not committed, and therefore free to use for new orders.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.execmode-Union{Tuple{Strategies.Strategy{M}}, Tuple{M}} where M<:Misc.ExecMode","page":"Strategies","title":"Misc.execmode","text":"Returns the strategy execution mode.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.marginmode-Union{Tuple{Strategies.Strategy{X, N, E, M}}, Tuple{M}, Tuple{E}, Tuple{N}, Tuple{X}} where {X, N, E, M<:Misc.MarginMode}","page":"Strategies","title":"Misc.marginmode","text":"Get the strategy margin mode.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.reset!","page":"Strategies","title":"Misc.reset!","text":"Resets strategy state. defaults: if true reapply strategy config defaults.\n\n\n\n\n\n","category":"function"},{"location":"API/strategies/#Strategies.assets-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.assets","text":"Assets loaded by the strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.default!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.default!","text":"Set strategy defaults.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.exchange-Tuple{S} where S<:Strategies.Strategy","page":"Strategies","title":"Strategies.exchange","text":"Strategy main exchange id.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.instances-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.instances","text":"Strategy assets instance.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.lasttrade_price_func-Tuple{Any}","page":"Strategies","title":"Strategies.lasttrade_price_func","text":"The asset close price of the candle where the last trade was performed.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.ping!-Tuple{Strategies.Strategy, Dates.DateTime, Any}","page":"Strategies","title":"Strategies.ping!","text":"Called on each timestep iteration, possible multiple times. Receives:\n\ncurrent_time: the current timestamp to evaluate (the current candle would be current_time - timeframe).\nctx: The context of the executor.\n\nping!(\n    _::Strategies.Strategy,\n    current_time::Dates.DateTime,\n    ctx\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.ping!-Tuple{Strategies.Strategy, OrderTypes.Order, OrderTypes.OrderError, Instances.AssetInstance15}","page":"Strategies","title":"Strategies.ping!","text":"When an order is cancelled the strategy is pinged with an order error. \n\nping!(\n    ::Strategies.Strategy,\n    ::OrderTypes.Order,\n    err::OrderTypes.OrderError,\n    ::Instances.AssetInstance15;\n    kwargs...\n) -> OrderTypes.OrderError\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.ping!-Tuple{Strategies.Strategy, Strategies.ResetStrategy}","page":"Strategies","title":"Strategies.ping!","text":"Called at the end of the reset! function applied to a strategy.\n\nping!(_::Strategies.Strategy, _::Strategies.ResetStrategy)\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.ping!-Tuple{Strategies.Strategy, Strategies.WarmupPeriod}","page":"Strategies","title":"Strategies.ping!","text":"How much lookback data the strategy needs. \n\nping!(\n    s::Strategies.Strategy,\n    _::Strategies.WarmupPeriod\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.ping!-Tuple{Type{<:Strategies.Strategy}, Any, Strategies.LoadStrategy}","page":"Strategies","title":"Strategies.ping!","text":"Called to construct the strategy, should return the strategy instance.\n\nping!(\n    _::Type{<:Strategies.Strategy},\n    cfg,\n    _::Strategies.LoadStrategy\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.reload!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.reload!","text":"Reloads ohlcv data for assets already present in the strategy universe.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.sizehint!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.sizehint!","text":"Keeps track of max allocated containers size for strategy and asset instances in the universe.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.trades_count-Tuple{Strategies.Strategy, Val{:liquidations}}","page":"Strategies","title":"Strategies.trades_count","text":"All trades in the strategy universe excluding liquidations, returns the tuple (trades, liquidations).\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.trades_count-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.trades_count","text":"All trades recorded in the strategy universe (includes liquidations).\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.tradesedge-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.tradesedge","text":"The first and last trade of any asset in the strategy universe.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.tradesedge-Tuple{Type{Dates.DateTime}, Strategies.Strategy}","page":"Strategies","title":"Strategies.tradesedge","text":"The dates of the first and last trade present in the strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.tradesperiod-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.tradesperiod","text":"The recorded trading Period, from the trades history present in the strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.tradesrange","page":"Strategies","title":"Strategies.tradesrange","text":"A DateRange spanning the historical time period of the trades recorded by the strategy.\n\n\n\n\n\n","category":"function"},{"location":"API/data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"API/data/","page":"Data","title":"Data","text":"Modules = [PingPong.Data]","category":"page"},{"location":"API/data/#Data.OHLCVTuple","page":"Data","title":"Data.OHLCVTuple","text":"Similar to a StructArray (and should probably be replaced by it), used for fast conversion.\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Data.ZarrInstance","page":"Data","title":"Data.ZarrInstance","text":"Candles data is stored with hierarchy PAIR -> [TIMEFRAMES...]. A pair is a ZGroup, a timeframe is a ZArray.\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Base.unique!-Tuple{Function, Zarr.ZArray}","page":"Data","title":"Base.unique!","text":"Remove duplicate from a zarray.\n\nIn a 2d zarray where we want values where the second column is unique:\n\nunique!(x->x[2], z)\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data._load_ohlcv-Tuple{Zarr.ZArray, Any}","page":"Data","title":"Data._load_ohlcv","text":"Load ohlcv pair data from zarr instance. za: The zarr array holding the data key: the name of the array to load from the zarr instance (in the format exchange/timeframe/pair) td: the timeframe (as integer in milliseconds) of the target ohlcv table to be loaded from, to: date range\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data._save_data-Tuple{Data.ZarrInstance, Any, Any}","page":"Data","title":"Data._save_data","text":"Saves data to a zarr array ensuring only dates seriality, not contiguity (as opposed to _save_ohlcv).\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.candleat-Tuple{DataFrames.AbstractDataFrame, Dates.DateTime}","page":"Data","title":"Data.candleat","text":"Get the candle at given date from a ohlcv dataframe as a Candle.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.candlelast-Tuple{DataFrames.AbstractDataFrame}","page":"Data","title":"Data.candlelast","text":"Get the last candle from a ohlcv dataframe as a Candle.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.candlepair-Tuple{DataFrames.AbstractDataFrame, Dates.DateTime}","page":"Data","title":"Data.candlepair","text":"Same as candleat but also fetches the previous candle, returning a Tuple{Candle, Candle}.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.chunksize-Tuple{Any}","page":"Data","title":"Data.chunksize","text":"Choose chunk size depending on size of data with a predefined split (e.g. 1/100), padding to the nearest power of 2.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.contiguous_ts-Tuple{Any, AbstractString}","page":"Data","title":"Data.contiguous_ts","text":"Checks if a timeseries has any intervals not conforming to the given timeframe.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.df!-Tuple","page":"Data","title":"Data.df!","text":"Construct a DataFrame without copying.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.empty_ohlcv-Tuple{}","page":"Data","title":"Data.empty_ohlcv","text":"An empty OHLCV dataframe.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.key_path-Tuple{Any, Any, Any}","page":"Data","title":"Data.key_path","text":"The full key of the data stored for the (exchange, pair, timeframe) combination.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.load-Tuple{Data.ZarrInstance, Any, Any, Any}","page":"Data","title":"Data.load","text":"Load a pair ohlcv data from storage. as_z: returns the ZArray\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.load_data-Tuple{Data.ZarrInstance, Any}","page":"Data","title":"Data.load_data","text":"Load data from zarr instance. zi: The zarr instance to use key: the name of the array to load from the zarr instance (full key path). type: Set to the type that zarr should use to store the data (only bits types). [Float64]. serialized: If set, data will be deserialized before returned (type is ignored). from, to: date range sz: The chunks tuple which should match the shape of the already saved data.\n\nwarning: Mismatching chunks\nLoading data with from key with wrong dimensions (ndims(sz)) or shape (columns) will reset the stored zarray.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.load_ohlcv-Tuple{Data.ZarrInstance, AbstractString, Any, Any}","page":"Data","title":"Data.load_ohlcv","text":"Load data from given zarr instance, exchange, pairs list and timeframe.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.save_ohlcv-Tuple{Data.ZarrInstance, Vararg{Any, 4}}","page":"Data","title":"Data.save_ohlcv","text":"data_col: the timestamp column of the new data (1) saved_col: the timestamp column of the existing data (1) pair: the trading pair (BASE/QUOTE string) timeframe: exchange timeframe (from exc.timeframes) type: Primitive type used for storing the data (Float64) check:\n\n:bounds (default) only checks that new data is adjacent to previous data.\n:all checks full contiguity of previous and new data.\n:none or anything else, no checks are done.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.snakecased-Tuple{AbstractString}","page":"Data","title":"Data.snakecased","text":"Normalizes or special characthers separators to _.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.to_ohlcv-Tuple{Matrix}","page":"Data","title":"Data.to_ohlcv","text":"Convert raw ccxt OHLCV data (matrix) to a dataframe.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.zdelete!-Tuple{Zarr.ZArray, Union{Nothing, Dates.DateTime}, Union{Nothing, Dates.DateTime}}","page":"Data","title":"Data.zdelete!","text":"Delete elements from a ZArray within the range of dates from_dt:to_dt.\n\nUse the select function to customize the dates vector where to index th range. Defaults to the first column of a 2D Zarray.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.zilmdb","page":"Data","title":"Data.zilmdb","text":"Create a ZarrInstance at specified path using lmdb as backend.\n\nforce: resets the underlying store.\n\n\n\n\n\n","category":"function"},{"location":"API/data/#Data.@as_mat-Tuple{Any}","page":"Data","title":"Data.@as_mat","text":"Redefines given variable to a Matrix with type of the underlying container type.\n\n\n\n\n\n","category":"macro"},{"location":"API/data/#Data.@to_mat","page":"Data","title":"Data.@to_mat","text":"Same as as_mat but returns the new matrix.\n\n\n\n\n\n","category":"macro"},{"location":"API/pbar/#Pbar","page":"Pbar","title":"Pbar","text":"","category":"section"},{"location":"API/pbar/","page":"Pbar","title":"Pbar","text":"Modules = [Pbar]","category":"page"},{"location":"API/pbar/#Pbar.Pbar","page":"Pbar","title":"Pbar.Pbar","text":"Progress bar wrapper.\n\n\n\n\n\n","category":"module"},{"location":"API/pbar/#Pbar.frequency!-Tuple{Any}","page":"Pbar","title":"Pbar.frequency!","text":"Set the update frequency globally.\n\n\n\n\n\n","category":"method"},{"location":"API/pbar/#Pbar.pbclose!","page":"Pbar","title":"Pbar.pbclose!","text":"Terminates the progress bar.\n\n\n\n\n\n","category":"function"},{"location":"API/pbar/#Pbar.transient!","page":"Pbar","title":"Pbar.transient!","text":"Toggles pbar transient flag\n\n\n\n\n\n","category":"function"},{"location":"API/pbar/#Pbar.@pbar!","page":"Pbar","title":"Pbar.@pbar!","text":"Instantiate a progress bar:\n\ndata: length(data) determines the bar total\nunit: what unit the display\ndesc: description will appear over the progressbar\n\n\n\n\n\n","category":"macro"},{"location":"API/pbar/#Pbar.@pbupdate!","page":"Pbar","title":"Pbar.@pbupdate!","text":"Single update to the progressbar with the new value.\n\n\n\n\n\n","category":"macro"},{"location":"API/pbar/#Pbar.@withpbar!-Tuple{Any, Vararg{Any}}","page":"Pbar","title":"Pbar.@withpbar!","text":"Same as @pbar! but with implicit closing. The first argument should be the collection to iterate over. Optional kw arguments:\n\ndesc: description\n\n\n\n\n\n","category":"macro"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The Plotting module is based on Makie. Backends are not included in the package dependencies so you need to add one yourself:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"] add GLMakie\nusing GLMakie\n# or\n] add WGLMakie\nusing WGLMakie","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"PingPong provides recipes for plotting:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"OHLCV\nFine grained trades history\nAggregated trades history with volume and balance.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"info: Interactivity\nPlots generated using makie interactive backends (GLMakie and WGLMakie) can be dragged and zoomed. There are tooltips (on hover) for candles, trades and balance plots.","category":"page"},{"location":"plotting/#OHLCV","page":"Plotting","title":"OHLCV","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"We plot ohlcv data using candlesticks, colored in red/green, and volume bars in the background.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Plotting\nusing Scrapers.BinanceData\ndf = binanceload(\"eth\").data\nfig = Plotting.ohlcv(df)\ndisplay(fig)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: OHLCV Plot)","category":"page"},{"location":"plotting/#Trades-history","page":"Plotting","title":"Trades history","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"We plot trades history as triangles pointing up for buys and down for sells.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Lang\nusing Strategies\nusing Engine.Executors.SimMode: SimMode as bt\ns = st.strategy(:Example)\nai = s.universe[m\"eth\"].instance\nbt.backtest!(s)\n# Plot the first 100 trades for the first asset matching symbol \"eth\"\nfig = Plotting.tradesticks(s, m\"eth\", to=100)\ndisplay(fig)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: TradesTicks)","category":"page"},{"location":"plotting/#Aggregated-trades-history-for-single-asset","page":"Plotting","title":"Aggregated trades history for single asset","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For a high level view of the trades density there is the balloons function. It aggregates all trades that have happened in a single timeframe. The bigger the circle the higher is the volume. Timeframes with positive volume are considered sells and the opposite for buys. The less transparent the circle the more trades have happened in the timeframe. The plot at the bottom shows the balance, in quote currency held. The first band (orange) is actual cash (from Strategy.cash) while the other (blue) is the value of held assets in quote currency (AssetInstance.cash * price).","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Aggreggate trades within 1 day for the first asset matching \"eth\".\nPlotting.balloons(s, m\"eth\", tf=tf\"1d\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Ballons)","category":"page"},{"location":"plotting/#Aggregated-trades-history-for-multiple-assets","page":"Plotting","title":"Aggregated trades history for multiple assets","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"When plotting aggregated history for all strategy assets, we overlay balloons over the priceline of each asset. Opacity and balloon radius properties are the same as for single asset plots. Alternatively passing a symbol or a dataframe as benchmark kwarg will plot all aggregations over that single asset OHLCV data.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Aggreggate trades within 1 day for all the assets in the strategy universe\nPlotting.balloons(s, tf=tf\"1w\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Ballons Multi)","category":"page"},{"location":"plotting/#Custom-indicators","page":"Plotting","title":"Custom indicators","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For plotting a moving average we can use the line_indicator function.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"analyze!()\nusing Indicators\nm7 = Indicators.sma(df.close, n=7)\nm14 = Indicators.sma(df.close, n=14)\nfig = Plotting.ohlcv(df);\nfig = line_indicator!(fig, m7, m14)\ndisplay(fig)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Line Indicator)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For channels/envelopes we can use the channel_indicator function.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"bb = Indicators.bbands(df.close)\nPlotting.channel_indicator(df, eachcol(bb)...)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Channel Indicator)","category":"page"},{"location":"#What-is-PingPong?","page":"What is PingPong?","title":"What is PingPong?","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"PingPong is a bot for running automated trading strategies. It allows for interactive experimentation of new strategies through the julia REPL, and their live deployment to trading exchanges with almost zero code replication.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"The bot is based around the concept of strategies. A strategy requires a primary currency which represents its balance and a primary exchange where all the orders will be forwarded (and against which they will be checked for validity).","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Writing a pingpong strategy is equivalent to writing a julia module, that the bot will load (either dynamically or statically on deployments). Within the module you import the pingpong interface, such that you can specialize ping! entry functions relative only to your strategy, the rest is up to you.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"The framework provides a long list of convenience or utility functions to manipulate the strategy and assets objects defined in different modules. In fact the bot is quite modular and is made of almost 30 packages, even though the majority of them is required to actually run the bot.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"From the strategy you can manage orders through pong! functions and expect them to be executed during simulation and live trading (through the CCXT library) while returning the same data structures even if populated through different means.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"The advantage of PingPong over trading bots written in other programming languages is its flexibility thanks to the julia parametric type system that allows to extend the bot by specializing functions to perform ad hoc logic. An exchange is behaving differently compared to others? You can specialize the balance function over only that particular exchange by defining:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"balance(exc::Exchange{:MyQuirkyExchange}, args...) ... end","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"where :MyQuirkyExchange is the ExchangeID symbol of the exchange you are targeting. ","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"This is how strategy ping! functions also dispatch, because the strategies always have in their type parameters the Symbol which matches the module of the strategy itself. Indeed you cannot define multiple strategies with the same name. And it is also how we are able to have almost zero code duplication between simulation and live trading, the execution mode is just another type parameter of the strategy.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"The bot has tools to download, clean and store data, that make use of popular julia libraries. See Data, and tools to resample time series see Processing.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"It can track live data like tickers, trades, ohlcv, see Watchers.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"It can compute statistics about backtest runs, see Stats","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"It can generate interactive and fully browsable plots for ohlcv data, indicators and backtesting runs, see Plotting","category":"page"},{"location":"#Quickstart","page":"What is PingPong?","title":"Quickstart","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Launch julia and activate the package:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"git clone https://github.com/panifie/PingPong.jl\ncd PingPong.jl\njulia --project=./PingPong","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Instantiate dependencies:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"using Pkg: Pkg\nPkg.instantiate()\nusing PingPong","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Load the default strategy, which you can look up at ./user/strategies/Example.jl","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"using Engine.Strategies\ns = strategy(:Example)","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Download some data:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"using Instruments\npairs = raw.(s.universe.data.asset)\nusing Scrapers: BinanceData as bn\nbn.binancedownload(pairs)","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Load the data into the strategy universe:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"using Engine.Collections: stub!\nlet data = bn.binanceload(pairs)\n    stub!(s.universe, data)\nend","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Backtest the strategy within the period available from the loaded data.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"using Engine.Executors.SimMode: SimMode as bt\nbt.backtest!(s)","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Plot the simulated trades:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"PingPong.plots!()\n","category":"page"},{"location":"#Packages","page":"What is PingPong?","title":"Packages","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Here's a list of the most important underlying packages.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Engine: The actual backtest engine.\nStrategies: Types and concept for building strategies.\nExchanges: Loads exchanges instances, markets and pairlists, based on ccxt.\nPlotting: Output plots for ohlcv data, indicators, backtests, based on Makie.\nData: Loading and saving ohlcv data (and more), based Zarr.\nStats: Statistics about backtests, and live operations.\nProcessing: Data cleanup, normalization, resampling functions.\nWatchers: Services for data pipelines, from sources to storage.\nMisc: Ancillary stuff, like configuration, and some UI bits.\nAnalysis: The bulk of indicators evaluation, depends of a bunch of (heavy) julia libraries like CausalityTools and Indicators. Most of the package is implemented through optional deps such that you only import what you need.","category":"page"},{"location":"#Infos","page":"What is PingPong?","title":"Infos","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Troubleshooting\nDevdocs\nContacts","category":"page"},{"location":"API/processing/#Processing","page":"Processing","title":"Processing","text":"","category":"section"},{"location":"API/processing/","page":"Processing","title":"Processing","text":"Modules = [Processing]","category":"page"},{"location":"API/processing/#Processing.cleanup_ohlcv_data-Tuple{Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.cleanup_ohlcv_data","text":"Similar to the freqtrade homonymous function.\n\nfill_missing: :close fills non present candles with previous close and 0 volume, else with NaN.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.fill_missing_candles-Tuple{Any, AbstractString}","page":"Processing","title":"Processing.fill_missing_candles","text":"Assuming timestamps are sorted, returns a new dataframe with a contiguous rows based on timeframe. Rows are filled either by previous close, or NaN. \n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.iscomplete-Tuple{Any, Any}","page":"Processing","title":"Processing.iscomplete","text":"Checks if a candle is old enough to be complete.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.isincomplete-Tuple{Data.Candle, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isincomplete","text":"Checks if a candle is too new.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.islast-Tuple{Dates.DateTime, Any, Val{:raw}}","page":"Processing","title":"Processing.islast","text":"Checks if a candle is exactly the latest candle.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.isleftadj-Tuple{Any, Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isleftadj","text":"a is left adjacent to b if in order ..ab..\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.isrightadj-Tuple{Any, Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isrightadj","text":"a is right adjacent to b if in order ..ba..\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.maptf-Tuple{AbstractVector{T} where T<:String, Any, Function}","page":"Processing","title":"Processing.maptf","text":"Apply a function over data, resampling data to each timeframe in tfs.\n\nf: signature is (data; kwargs...)::DataFrame\ntfsum: sum the scores across multiple timeframes for every pair.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.normalize!-Tuple{Any}","page":"Processing","title":"Processing.normalize!","text":"Applies either a unitrange transform or a zscore tranform over the data in place.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.resample","page":"Processing","title":"Processing.resample","text":"Resamples ohlcv data from a smaller to a higher timeframe.\n\nstyle: how to modify the data, (arguments to the grouped dataframe) [:ohlcv]\n\n\n\n\n\n","category":"function"},{"location":"API/processing/#Processing.resample-Tuple","page":"Processing","title":"Processing.resample","text":"Resamples data, and saves to storage.\n\nwarning: Usually not worth it\nResampling is quite fast, so it is simpler to keep only the smaller timeframe on storage, and resample the longer ones on demand.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.trail!-Tuple{Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.trail!","text":"Appends empty candles to df up to to datetime (excluded). cap: max capacity of df\n\n\n\n\n\n","category":"method"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"By learning the main types you get to know the building blocks to start composing your strategy for backtesting and/or live trading.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"info: Numbered types\nSome types have a number at the end, you can just ignore it, eventually it will be removed.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"The main type is the Strategy and it has its own page. Other important types follow.","category":"page"},{"location":"types/#Instruments","page":"Types","title":"Instruments","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Asset and Derivative are implementations of the AbstractAsset abstract type, defined in the Instruments package. They are what we get usually after parsing a string. Assets are most of the time a spot pair of base and quote currency. A Derivative is instead either a swap or a contract with a settlment date. These are \"static\" kind of structures that don't query real time data. The only information they hold is what can be parsed by the string itself.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"raw: The substring that was parsed.\nbc: base currency\nqc: quote currency\nfiat: true if the pair involves to \"stable\" currencies, which is a static list defined in Instruments.fiatnames\nleveraged: true if the base currency is a leveraged token, which is a kind of token that usually involves periodic rebalancing. This should be considered only as additional info, and unreliable, since there isn't a standard for naming such assets.\nunleveraged_bc: if the pair is leveraged, this should return the base currency without the \"multiplier\", such that you can use it to find similar markets of the same currency.","category":"page"},{"location":"types/#Derivatives-only-fields","page":"Types","title":"Derivatives only fields","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"asset: the simpler Asset type which forwards all its fields.\nsc: the settlement currency\nid: a string, usually representing the settlement date\nstrike: strike price of the contract\nkind: if its an option, either Call or Put, otherwise Unkn (unknown)","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Asset can be conveniently constructed from the REPL using a\"BTC/USDT\" or d\"BTC/USDT:USDT\" for Derivatives.","category":"page"},{"location":"types/#Asset-instances","page":"Types","title":"Asset instances","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"The AssetInstance is the richer type that refers to a particular asset, they are not parametrized over a particular asset (as that would cause \"type explosion\") but only over the AbstractAsset implementation, the exchange and the margin mode. An asset instance information is therefore always related to a specific exchange, cash(ai) for example should return how much cash is available for that asset on the exchange matching the instance ExchangeID parameter.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"asset: The underlying implementaion of AbstractAsset\ndata: a SortedDict (smallest to largest) of ohlcv data. The key is is a TimeFrame, the value is a DataFrame with columns timestamp,high,open,low,close,volume.\nhistory: the trades history of the asset\nlogs: AssetEvents like leverage updates in case of assets with active margin.\ncash: owned cash\ncash_committed: total cash used by pending orders\nexchange: the exchange of this asset instance\nlongpos/shortpos the Positions when margin mode is activate. committed/cash refers to the position cash within margin trading.\nlimits/precision: see ccxt\nfees: the fees in decimal percentage for trading for taker or maker.","category":"page"},{"location":"types/#Positions","page":"Types","title":"Positions","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"When trading with margin, asset instances state manage the status of long or short positions. In NotHedged mode (the default) you can only have either a long or short position open at any given time. Positions cash and cash_committed replace the asset instance own fields.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"status: If the position is either open PositionOpen() or close PositionClose().\nasset: Derivative inherited from the asset instance\ntimestamp: the last time the position was updated either by updating leverage, adding margin or increasing the position.\nliquidation_price: the price that would trigger a liquidation event\nentryprice: the average price of entry of the position\nmaintenance_margin: the minimum margin required to avoid liquidation (in quote currency)\ninitial_margin: the minimum margin required to open the position\nadditional_margin: margin added on top of the initial margin\nnotional: the value of the position w.r.t. the current price\ncash/cash_committed: the amount held, should always be equal to number of contracts multiplied by the contract size.\nleverage: the leverage factor\nmin_size: same as limits.cost.min of the asset instance\nhedged: true if margin mode is hedged.\ntiers: it is a LeverageTiersDict defined in the Exchanges module. It is parsed from ccxt, it is required to fetch the correct maintenance margin rate w.r.t. the position size.\nthis_tier: the current tier of the position, updated when the notional value changes.","category":"page"},{"location":"types/#Orders","page":"Types","title":"Orders","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Orders types parameters are:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"OrderType{<:OrderSide}: The order type is an abstract type with the OrderSide parameter which is Buy, Sell, and rarely Both. An OrderType can be for example a LimitOrderType or a MarketOrderType. These types are themselves supertypes for more specific orders like FOKOrderType and GTCOrderType. Creating order instances parametrized with different kinds should produce different behaviour in order execution.\nAbstractAsset, ExchangeID: same as asset instances, orders refer to a kind of asset on a specific exchange.\nPositionSide: either Long or Short, the order refer to either a long or short position. Once the order is filled, it's amount will be added to the cash of the matching position.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Orders have mostly simple data fields:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"asset: the AbstractAsset implementation that refers to it\nexc: the ExchangeID of the matching exchange\ndate: the date the order was opened\nprice: the target price of the order, for market orders this would be the last price before the order was opened.\namount: the total amount requested by the order\nattrs: A unspecified named tuple that is used to hold custom data specific to order types.","category":"page"},{"location":"types/#Trades","page":"Types","title":"Trades","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Trades are \"atomic\" events, orders are composed of one or more trades. They have the same type parameters as the orders, a trade for a specific order matches its exact type parameters.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"order: the order to which this trade belongs to\ndate: execution date of the trade\namount: The sum of the amounts of all the trades performed by an order is always below or equal the order amount.\nprice: the price can differ from the order price depending on wheter the order is a limit or market order.\nvalue: price * amount\nfees: the fees of the trade, in quote currency, they can be positive or negative (they are favorable if negative)\nsize: price * amount +/- fees\nleverage: the leverage that was used for the order and which the trade was executed with. We currently don't allow to change the leverage while there are open orders, therefore trades that belong to the same order should have the same leverage. Without margin the leverage should be always equal to 1.0.","category":"page"},{"location":"types/#Dates","page":"Types","title":"Dates","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"The julia main Dates package is never imported directly. It is instead exported by the package TimeTicks which among many utility functions overrides the now function to always use the UTC timezone. A very important type is the TimeFrame type which defines a segment of time, most of the times the concrete type of a TimeFrame will be a time period (Dates.Period).","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"For convenience timeframes can be constructed like tf\"1m\" for a 1 minute timeframe. This notation can be freely used as you like because by using the macro, the timeframe is replaced at compiled time, moreover construction is cached and the instances are singletons (@assert tf\"1m\" === tf\"1m\"). Parsing is also cached but only by calling convert(TimeFrame, v) or timeframe(v) and spend only the lookup cost (~500ns). The parsing is done to matching timeframe naming used within CCTX, and the timeperiod use should be expect to be in Millisecond.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Dates can also be constructed within the repl using the dt prefix like dt\"2020-\" will create a DateTime value for the date 2020-01-01T00:00:00. We also implement a DateRange which is used to keep track of the time between two dates, and it also works as an iterator when the step field (Period) is defined. Date ranges can be conveniently created using the prefix dtr like dtr\"2020-..2021-\" will construct a daterange for the full year 2020. You can specify the date precision up to the second as specified by the standard likedtr\"2020-01-01T:00:00:01..2021-01-01T00:00:01\"","category":"page"},{"location":"types/#OHLCV","page":"Types","title":"OHLCV","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"We use the DataFrames package, so when we refer to ohlcv data there is a DataFrame involved. Within the Data package there multiple utility functions to deal with ohlcv data, like ohlcv/at(df, date) to get the value of a column at a particular index by date, for example closeat(df, date). We implemented date indexing for dataframes so you can also directly call df[dt\"2020-01-01\", :close] to fetch the close value at the nearest matching date, or use a DateRange to slice the dataframe for the rows within the daterange time span (df[dtr\"2020-..2021-\"]). ","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"There are utility functions for guessing the timeframe of ohlcv data frame by looking at the difference between timestamps, calling timeframe!(df) will set the \"timeframe\" key on the metadata of the timestamp column of the dataframe.","category":"page"}]
}
